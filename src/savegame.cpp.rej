***************
*** 17,41 ****
  
  #include "savegame.hpp"
  
- #include "save_index.hpp"
  #include "carryover.hpp"
  #include "cursor.hpp"
  #include "format_time_summary.hpp"
  #include "formatter.hpp"
  #include "formula/string_utils.hpp"
  #include "game_end_exceptions.hpp"
  #include "game_errors.hpp"
- #include "preferences/game.hpp"
  #include "gettext.hpp"
  #include "gui/dialogs/game_load.hpp"
  #include "gui/dialogs/game_save.hpp"
  #include "gui/dialogs/message.hpp"
- #include "gui/dialogs/campaign_difficulty.hpp"
  #include "gui/dialogs/transient_message.hpp"
- #include "gui/widgets/settings.hpp"
  #include "gui/widgets/retval.hpp"
  #include "log.hpp"
  #include "persist_manager.hpp"
  #include "resources.hpp"
  #include "save_index.hpp"
  #include "saved_game.hpp"
--- 17,43 ----
  
  #include "savegame.hpp"
  
  #include "carryover.hpp"
  #include "cursor.hpp"
  #include "format_time_summary.hpp"
  #include "formatter.hpp"
  #include "formula/string_utils.hpp"
+ #include "game_config_manager.hpp"
+ #include "game_config_view.hpp"
  #include "game_end_exceptions.hpp"
  #include "game_errors.hpp"
+ #include "game_version.hpp"
  #include "gettext.hpp"
+ #include "gui/dialogs/campaign_difficulty.hpp"
  #include "gui/dialogs/game_load.hpp"
  #include "gui/dialogs/game_save.hpp"
  #include "gui/dialogs/message.hpp"
  #include "gui/dialogs/transient_message.hpp"
  #include "gui/widgets/retval.hpp"
+ #include "gui/widgets/settings.hpp"
  #include "log.hpp"
  #include "persist_manager.hpp"
+ #include "preferences/game.hpp"
  #include "resources.hpp"
  #include "save_index.hpp"
  #include "saved_game.hpp"
***************
*** 43,52 ****
  #include "serialization/parser.hpp"
  #include "serialization/utf8_exception.hpp"
  #include "statistics.hpp"
- #include "game_version.hpp"
  #include "video.hpp"
- #include "game_config_view.hpp"
- #include "game_config_manager.hpp"
  
  #include <algorithm>
  #include <iomanip>
--- 45,51 ----
  #include "serialization/parser.hpp"
  #include "serialization/utf8_exception.hpp"
  #include "statistics.hpp"
  #include "video.hpp"
  
  #include <algorithm>
  #include <iomanip>
***************
*** 152,166 ****
  
  	// Confirm the integrity of the file before throwing the exception.
  	// Use the summary in the save_index for this.
- 	const config & summary = load_data_.manager->get(load_data_.filename);
  
- 	if (summary["corrupt"].to_bool(false)) {
- 		gui2::show_error_message(
- 				_("The file you have tried to load is corrupt: '"));
  		return false;
  	}
  
- 	if (!loadgame::check_version_compatibility(summary["version"].str())) {
  		return false;
  	}
  
--- 149,162 ----
  
  	// Confirm the integrity of the file before throwing the exception.
  	// Use the summary in the save_index for this.
+ 	const config& summary = load_data_.manager->get(load_data_.filename);
  
+ 	if(summary["corrupt"].to_bool(false)) {
+ 		gui2::show_error_message(_("The file you have tried to load is corrupt: '"));
  		return false;
  	}
  
+ 	if(!loadgame::check_version_compatibility(summary["version"].str())) {
  		return false;
  	}
  
***************
*** 223,253 ****
  	return loadgame::check_version_compatibility(gamestate_.classification().version);
  }
  
- bool loadgame::check_version_compatibility(const version_info & save_version)
  {
- 	if (save_version == game_config::wesnoth_version) {
  		return true;
  	}
  
- 	const version_info &wesnoth_version = game_config::wesnoth_version;
  
  	// Even minor version numbers indicate stable releases which are
  	// compatible with each other.
- 	if (wesnoth_version.minor_version() % 2 == 0 &&
- 	    wesnoth_version.major_version() == save_version.major_version() &&
- 	    wesnoth_version.minor_version() == save_version.minor_version())
- 	{
  		return true;
  	}
  
  	// Do not load if too old. If either the savegame or the current
  	// game has the version 'test', load. This 'test' version is never
  	// supposed to occur, except when Soliton is testing MP servers.
- 	if (save_version < game_config::min_savegame_version &&
- 	    save_version != game_config::test_version &&
- 	    wesnoth_version != game_config::test_version)
- 	{
- 		const std::string message = _("This save is from an old, unsupported version ($version_number|) and cannot be loaded.");
  		utils::string_map symbols;
  		symbols["version_number"] = save_version.str();
  		gui2::show_error_message(utils::interpolate_variables_into_string(message, &symbols));
--- 218,245 ----
  	return loadgame::check_version_compatibility(gamestate_.classification().version);
  }
  
+ bool loadgame::check_version_compatibility(const version_info& save_version)
  {
+ 	if(save_version == game_config::wesnoth_version) {
  		return true;
  	}
  
+ 	const version_info& wesnoth_version = game_config::wesnoth_version;
  
  	// Even minor version numbers indicate stable releases which are
  	// compatible with each other.
+ 	if(wesnoth_version.minor_version() % 2 == 0 && wesnoth_version.major_version() == save_version.major_version()
+ 		&& wesnoth_version.minor_version() == save_version.minor_version()) {
  		return true;
  	}
  
  	// Do not load if too old. If either the savegame or the current
  	// game has the version 'test', load. This 'test' version is never
  	// supposed to occur, except when Soliton is testing MP servers.
+ 	if(save_version < game_config::min_savegame_version && save_version != game_config::test_version
+ 		&& wesnoth_version != game_config::test_version) {
+ 		const std::string message
+ 			= _("This save is from an old, unsupported version ($version_number|) and cannot be loaded.");
  		utils::string_map symbols;
  		symbols["version_number"] = save_version.str();
  		gui2::show_error_message(utils::interpolate_variables_into_string(message, &symbols));
***************
*** 507,518 ****
  	out.close_child("statistics");
  }
  
- void savegame::finish_save_game(const config_writer &out)
  {
  	try {
  		if(!out.good()) {
  			throw game::save_game_failed(_("Could not write to file"));
  		}
  		save_index_manager_->remove(gamestate_.classification().label);
  	} catch(const filesystem::io_exception& e) {
  		throw game::save_game_failed(e.what());
--- 504,516 ----
  	out.close_child("statistics");
  }
  
+ void savegame::finish_save_game(const config_writer& out)
  {
  	try {
  		if(!out.good()) {
  			throw game::save_game_failed(_("Could not write to file"));
  		}
+ 
  		save_index_manager_->remove(gamestate_.classification().label);
  	} catch(const filesystem::io_exception& e) {
  		throw game::save_game_failed(e.what());
***************
*** 636,652 ****
  	savegame::write_game(out);
  
  	gamestate().write_carryover(out);
- 	out.write_child("snapshot",gamestate().get_starting_point());
  	out.write_child("replay_start", gamestate().replay_start());
  	out.open_child("replay");
  	gamestate().get_replay().write(out);
  	out.close_child("replay");
  }
  
- //changes done during 1.11.0-dev
  static void convert_old_saves_1_11_0(config& cfg)
  {
- 	if(!cfg.has_child("snapshot")){
  		return;
  	}
  
--- 638,654 ----
  	savegame::write_game(out);
  
  	gamestate().write_carryover(out);
+ 	out.write_child("snapshot", gamestate().get_starting_point());
  	out.write_child("replay_start", gamestate().replay_start());
  	out.open_child("replay");
  	gamestate().get_replay().write(out);
  	out.close_child("replay");
  }
  
+ // changes done during 1.11.0-dev
  static void convert_old_saves_1_11_0(config& cfg)
  {
+ 	if(!cfg.has_child("snapshot")) {
  		return;
  	}
  
***************
*** 654,714 ****
  	const config& replay_start = cfg.child("replay_start");
  	const config& replay = cfg.child("replay");
  
- 	if(!cfg.has_child("carryover_sides") && !cfg.has_child("carryover_sides_start")){
  		config carryover;
- 		//copy rng and menu items from toplevel to new carryover_sides
  		carryover["random_seed"] = cfg["random_seed"];
  		carryover["random_calls"] = cfg["random_calls"];
  		for(const config& menu_item : cfg.child_range("menu_item")) {
  			carryover.add_child("menu_item", menu_item);
  		}
  		carryover["difficulty"] = cfg["difficulty"];
  		carryover["random_mode"] = cfg["random_mode"];
- 		//the scenario to be played is always stored as next_scenario in carryover_sides_start
  		carryover["next_scenario"] = cfg["scenario"];
  
  		config carryover_start = carryover;
  
- 		//copy sides from either snapshot or replay_start to new carryover_sides
- 		if(!snapshot.empty()){
  			for(const config& side : snapshot.child_range("side")) {
  				carryover.add_child("side", side);
  			}
- 			//for compatibility with old savegames that use player instead of side
  			for(const config& side : snapshot.child_range("player")) {
  				carryover.add_child("side", side);
  			}
- 			//save the sides from replay_start in carryover_sides_start
  			for(const config& side : replay_start.child_range("side")) {
  				carryover_start.add_child("side", side);
  			}
- 			//for compatibility with old savegames that use player instead of side
  			for(const config& side : replay_start.child_range("player")) {
  				carryover_start.add_child("side", side);
  			}
- 		} else if (!replay_start.empty()){
  			for(const config& side : replay_start.child_range("side")) {
  				carryover.add_child("side", side);
  				carryover_start.add_child("side", side);
  			}
- 			//for compatibility with old savegames that use player instead of side
  			for(const config& side : replay_start.child_range("player")) {
  				carryover.add_child("side", side);
  				carryover_start.add_child("side", side);
  			}
  		}
  
- 		//get variables according to old hierarchy and copy them to new carryover_sides
- 		if(!snapshot.empty()){
- 			if(const config& variables_from_snapshot = snapshot.child("variables")){
  				carryover.add_child("variables", variables_from_snapshot);
  				carryover_start.add_child("variables", replay_start.child_or_empty("variables"));
- 			} else if (const config& variables_from_cfg = cfg.child("variables")){
  				carryover.add_child("variables", variables_from_cfg);
  				carryover_start.add_child("variables", variables_from_cfg);
  			}
- 		} else if (!replay_start.empty()){
- 			if(const config& variables = replay_start.child("variables")){
  				carryover.add_child("variables", variables);
  				carryover_start.add_child("variables", variables);
  			}
--- 656,718 ----
  	const config& replay_start = cfg.child("replay_start");
  	const config& replay = cfg.child("replay");
  
+ 	if(!cfg.has_child("carryover_sides") && !cfg.has_child("carryover_sides_start")) {
  		config carryover;
+ 		// copy rng and menu items from toplevel to new carryover_sides
  		carryover["random_seed"] = cfg["random_seed"];
  		carryover["random_calls"] = cfg["random_calls"];
+ 
  		for(const config& menu_item : cfg.child_range("menu_item")) {
  			carryover.add_child("menu_item", menu_item);
  		}
+ 
  		carryover["difficulty"] = cfg["difficulty"];
  		carryover["random_mode"] = cfg["random_mode"];
+ 		// the scenario to be played is always stored as next_scenario in carryover_sides_start
  		carryover["next_scenario"] = cfg["scenario"];
  
  		config carryover_start = carryover;
  
+ 		// copy sides from either snapshot or replay_start to new carryover_sides
+ 		if(!snapshot.empty()) {
  			for(const config& side : snapshot.child_range("side")) {
  				carryover.add_child("side", side);
  			}
+ 			// for compatibility with old savegames that use player instead of side
  			for(const config& side : snapshot.child_range("player")) {
  				carryover.add_child("side", side);
  			}
+ 			// save the sides from replay_start in carryover_sides_start
  			for(const config& side : replay_start.child_range("side")) {
  				carryover_start.add_child("side", side);
  			}
+ 			// for compatibility with old savegames that use player instead of side
  			for(const config& side : replay_start.child_range("player")) {
  				carryover_start.add_child("side", side);
  			}
+ 		} else if(!replay_start.empty()) {
  			for(const config& side : replay_start.child_range("side")) {
  				carryover.add_child("side", side);
  				carryover_start.add_child("side", side);
  			}
+ 			// for compatibility with old savegames that use player instead of side
  			for(const config& side : replay_start.child_range("player")) {
  				carryover.add_child("side", side);
  				carryover_start.add_child("side", side);
  			}
  		}
  
+ 		// get variables according to old hierarchy and copy them to new carryover_sides
+ 		if(!snapshot.empty()) {
+ 			if(const config& variables_from_snapshot = snapshot.child("variables")) {
  				carryover.add_child("variables", variables_from_snapshot);
  				carryover_start.add_child("variables", replay_start.child_or_empty("variables"));
+ 			} else if(const config& variables_from_cfg = cfg.child("variables")) {
  				carryover.add_child("variables", variables_from_cfg);
  				carryover_start.add_child("variables", variables_from_cfg);
  			}
+ 		} else if(!replay_start.empty()) {
+ 			if(const config& variables = replay_start.child("variables")) {
  				carryover.add_child("variables", variables);
  				carryover_start.add_child("variables", variables);
  			}
***************
*** 721,790 ****
  		cfg.add_child("carryover_sides_start", carryover_start);
  	}
  
- 	//if replay and snapshot are empty we've got a start of scenario save and don't want replay_start either
- 	if(replay.empty() && snapshot.empty()){
- 		LOG_RG<<"removing replay_start \n";
  		cfg.clear_children("replay_start");
  	}
  
- 	//remove empty replay or snapshot so type of save can be detected more easily
- 	if(replay.empty()){
- 		LOG_RG<<"removing replay \n";
  		cfg.clear_children("replay");
  	}
  
- 	if(snapshot.empty()){
- 		LOG_RG<<"removing snapshot \n";
  		cfg.clear_children("snapshot");
  	}
  }
- //changes done during 1.13.0-dev
  static void convert_old_saves_1_13_0(config& cfg)
  {
- 	if(config& carryover_sides_start = cfg.child("carryover_sides_start"))
- 	{
- 		if(!carryover_sides_start.has_attribute("next_underlying_unit_id"))
- 		{
  			carryover_sides_start["next_underlying_unit_id"] = cfg["next_underlying_unit_id"];
  		}
  	}
- 	if(cfg.child_or_empty("snapshot").empty())
- 	{
  		cfg.clear_children("snapshot");
  	}
- 	if(cfg.child_or_empty("replay_start").empty())
- 	{
  		cfg.clear_children("replay_start");
  	}
- 	if(config& snapshot = cfg.child("snapshot"))
- 	{
- 		//make [end_level] -> [end_level_data] since its alo called [end_level_data] in the carryover.
- 		if(config& end_level = cfg.child("end_level") )
- 		{
  			snapshot.add_child("end_level_data", end_level);
  			snapshot.clear_children("end_level");
  		}
- 		//if we have a snapshot then we already applied carryover so there is no reason to keep this data.
- 		if(cfg.has_child("carryover_sides_start"))
- 		{
  			cfg.clear_children("carryover_sides_start");
  		}
  	}
- 	if(!cfg.has_child("snapshot") && !cfg.has_child("replay_start"))
- 	{
  		cfg.clear_children("carryover_sides");
  	}
- 	//This code is needed because for example otherwise it won't find the (empty) era
  	if(!cfg.has_child("multiplayer")) {
- 		cfg.add_child("multiplayer", config {
- 			"mp_era", "era_blank",
- 			"mp_use_map_settings", true,
- 		});
  	}
  }
  
- 
- //changes done during 1.13.0+dev
  static void convert_old_saves_1_13_1(config& cfg)
  {
  	if(config& multiplayer = cfg.child("multiplayer")) {
--- 725,793 ----
  		cfg.add_child("carryover_sides_start", carryover_start);
  	}
  
+ 	// if replay and snapshot are empty we've got a start of scenario save and don't want replay_start either
+ 	if(replay.empty() && snapshot.empty()) {
+ 		LOG_RG << "removing replay_start \n";
  		cfg.clear_children("replay_start");
  	}
  
+ 	// remove empty replay or snapshot so type of save can be detected more easily
+ 	if(replay.empty()) {
+ 		LOG_RG << "removing replay \n";
  		cfg.clear_children("replay");
  	}
  
+ 	if(snapshot.empty()) {
+ 		LOG_RG << "removing snapshot \n";
  		cfg.clear_children("snapshot");
  	}
  }
+ // changes done during 1.13.0-dev
  static void convert_old_saves_1_13_0(config& cfg)
  {
+ 	if(config& carryover_sides_start = cfg.child("carryover_sides_start")) {
+ 		if(!carryover_sides_start.has_attribute("next_underlying_unit_id")) {
  			carryover_sides_start["next_underlying_unit_id"] = cfg["next_underlying_unit_id"];
  		}
  	}
+ 
+ 	if(cfg.child_or_empty("snapshot").empty()) {
  		cfg.clear_children("snapshot");
  	}
+ 
+ 	if(cfg.child_or_empty("replay_start").empty()) {
  		cfg.clear_children("replay_start");
  	}
+ 
+ 	if(config& snapshot = cfg.child("snapshot")) {
+ 		// make [end_level] -> [end_level_data] since its alo called [end_level_data] in the carryover.
+ 		if(config& end_level = cfg.child("end_level")) {
  			snapshot.add_child("end_level_data", end_level);
  			snapshot.clear_children("end_level");
  		}
+ 		// if we have a snapshot then we already applied carryover so there is no reason to keep this data.
+ 		if(cfg.has_child("carryover_sides_start")) {
  			cfg.clear_children("carryover_sides_start");
  		}
  	}
+ 
+ 	if(!cfg.has_child("snapshot") && !cfg.has_child("replay_start")) {
  		cfg.clear_children("carryover_sides");
  	}
+ 
+ 	// This code is needed because for example otherwise it won't find the (empty) era
  	if(!cfg.has_child("multiplayer")) {
+ 		cfg.add_child("multiplayer",
+ 			config{
+ 				"mp_era",
+ 				"era_blank",
+ 				"mp_use_map_settings",
+ 				true,
+ 			});
  	}
  }
  
+ // changes done during 1.13.0+dev
  static void convert_old_saves_1_13_1(config& cfg)
  {
  	if(config& multiplayer = cfg.child("multiplayer")) {
***************
*** 2650,2672 ****
  			}
  		}
  	}
  	for(config& snapshot : cfg.child_range("snapshot")) {
- 		if (snapshot.has_attribute("used_items")) {
  			config used_items;
  			for(const std::string& item : utils::split(snapshot["used_items"])) {
  				used_items[item] = true;
  			}
  			snapshot.remove_attribute("used_items");
  			snapshot.add_child("used_items", used_items);
  		}
  	}
  }
- //changes done during 1.15.3+dev
  static void convert_old_saves_1_15_3(config& cfg)
  {
  	if(cfg["era_id"].empty()) {
  		cfg["era_id"] = cfg.child_or_empty("multiplayer")["mp_era"];
  	}
  	if(cfg["active_mods"].empty()) {
  		cfg["active_mods"] = cfg.child_or_empty("multiplayer")["active_mods"];
  	}
--- 2649,2675 ----
  			}
  		}
  	}
+ 
  	for(config& snapshot : cfg.child_range("snapshot")) {
+ 		if(snapshot.has_attribute("used_items")) {
  			config used_items;
  			for(const std::string& item : utils::split(snapshot["used_items"])) {
  				used_items[item] = true;
  			}
+ 
  			snapshot.remove_attribute("used_items");
  			snapshot.add_child("used_items", used_items);
  		}
  	}
  }
+ 
+ // changes done during 1.15.3+dev
  static void convert_old_saves_1_15_3(config& cfg)
  {
  	if(cfg["era_id"].empty()) {
  		cfg["era_id"] = cfg.child_or_empty("multiplayer")["mp_era"];
  	}
+ 
  	if(cfg["active_mods"].empty()) {
  		cfg["active_mods"] = cfg.child_or_empty("multiplayer")["active_mods"];
  	}
***************
*** 2675,2699 ****
  void convert_old_saves(config& cfg)
  {
  	version_info loaded_version(cfg["version"]);
- 	if(loaded_version < version_info("1.12.0"))
- 	{
  		convert_old_saves_1_11_0(cfg);
  	}
  	// '<= version_info("1.13.0")' doesn't work
- 	//because version_info cannot handle 1.13.0-dev versions correctly.
- 	if(loaded_version < version_info("1.13.1"))
- 	{
  		convert_old_saves_1_13_0(cfg);
  	}
- 	if(loaded_version <= version_info("1.13.1"))
- 	{
  		convert_old_saves_1_13_1(cfg);
  	}
- 	if(loaded_version < version_info("1.15.4"))
- 	{
  		convert_old_saves_1_15_3(cfg);
  	}
- 	LOG_RG<<"cfg after conversion "<<cfg<<"\n";
- }
  
  }
--- 2678,2702 ----
  void convert_old_saves(config& cfg)
  {
  	version_info loaded_version(cfg["version"]);
+ 	if(loaded_version < version_info("1.12.0")) {
  		convert_old_saves_1_11_0(cfg);
  	}
+ 
  	// '<= version_info("1.13.0")' doesn't work
+ 	// because version_info cannot handle 1.13.0-dev versions correctly.
+ 	if(loaded_version < version_info("1.13.1")) {
  		convert_old_saves_1_13_0(cfg);
  	}
+ 
+ 	if(loaded_version <= version_info("1.13.1")) {
  		convert_old_saves_1_13_1(cfg);
  	}
+ 
+ 	if(loaded_version < version_info("1.15.4")) {
  		convert_old_saves_1_15_3(cfg);
  	}
  
+ 	LOG_RG << "cfg after conversion " << cfg << "\n";
  }
+ 
+ } // namespace savegame
