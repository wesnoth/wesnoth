#!/usr/bin/env python3


# encoding: utf-8
#
# wmlxgettext -- generate a blank .pot file for official campaigns translations
#                    (build tool for wesnoth core)
#
#
# By Nobun, october 2015
# Thanks to Elvish Hunter for writing code for coloring text under windows
#
#                              PURPOSE
#
# wmlxgettext is a python3 tool that replace the old (but very good)
# perl script with the same name.
# Replacing perl with python3 will ensure more portability.
#
# wmlxgettext is a tool that is directly used during wesnoth build process
# to generate the pot files for the core campaigns.
#
#                              USAGE
#
# If you want to learn how to use wmlxgettext, read the online End-User
# documentation at:
# http://wmlxgettext-unoff.readthedocs.org/en/latest/enduser/index.html
#
#                   SOURCE CODE DOCUMENTATION
#
# While the source code contains some comments that explain what it does at
# that point, the source code is mainly explained on source documentation at:
# http://wmlxgettext-unoff.readthedocs.org/en/latest/srcdoc/index.html

import argparse
from copy import copy
from datetime import datetime
import os
import signal
import sys
import warnings
import pywmlx
from wesnoth.wmltools3 import CrossRef
from wesnoth.wmlmacro import AST, Macro, CrossRefHelper, ReferenceHelper, GlobalWMLMacros

def commandline(args):
    parser = argparse.ArgumentParser(
        description='Generate .pot from WML/Lua file list.',
        usage='''wmlxgettext -o OUTPUT_DIR
                   [--domain=DOMAIN]
                   [--directory=START_PATH]
                   [--recursive] [--initialdomain=INITIAL_DOMAIN]
                   [--package-version=PACKAGE_VERSION]
                   [--no-sort-by-file] [--no-text-colors] [--fuzzy] [--warnall]
                   FILE1 FILE2 ... FILEN'''
    )
    parser.add_argument(
        '--version',
        action='version',
        version='wmlxgettext 2023.05.17.py3'
    )
    parser.add_argument(
        '-o',
        required=True,
        default=None,
        dest='folder',
        help= ('Destination folder. In some special situations you might want '
               'to write the output to STDOUT instead of writing '
               'an actual file (using "-o -"). On standard usage, however, '
               'you should avoid to write the output to STDOUT (or you may '
               'face some issues related to text encoding). '
               '[**REQUIRED ARGUMENT**]')
    )
    parser.add_argument(
        '--domain',
        nargs='*',
        dest='domain',
        help= ('One or more textdomain values (on WML/Lua file) associated to the '
               'strings that will be actually translated. ')
    )
    parser.add_argument(
        '--directory',
        default='.',
        dest='start_path',
        help=('Complete path of your "start directory". '
              '(Default: current directory). The (relative) path to '
              'every WML/Lua file should start from this directory.')
    )
    parser.add_argument(
        '--initialdomain',
        default='wesnoth',
        dest='initdom',
        help=('Initial domain value on WML/Lua file when no textdomain '
              'set in that WML/Lua file.\nBy default, it is equal to '
              '"wesnoth" and usually you don\'t need to change this value.')
    )
    parser.add_argument(
        '--package-version',
        default='PACKAGE VERSION',
        dest='package_version',
        help=('Version number of your wesnoth add-on. You don\'t actually '
              'require to set this option since you can directly edit the '
              'po file produced by wmlxgettext.')
    )
    parser.add_argument(
        '--no-sort-by-file',
        action='store_false',
        default=True,
        dest='sort_by_file',
        help=("By default, the list of input files is sorted so that they "
              "are processed in a deterministic order. Use this flag to "
              "process the files in the order that they're named on the "
              "command line.")
    )
    parser.add_argument(
        '--no-text-colors',
        action='store_false',
        default=True,
        dest='text_col',
        help=("By default, warnings are displayed with colored text. You can "
              "disable this feature using this flag.")
    )
    parser.add_argument(
        '--warnall',
        action='store_true',
        default=False,
        dest='warnall',
        help="Show all warnings. By default, some warnings are hidden."
    )
    parser.add_argument(
        '--fuzzy',
        action='store_true',
        default=False,
        dest='fuzzy',
        help=("If you specify this flag, all sentences in the POT "
              "files created by wmlxgettext will be set as fuzzy.\n"
              "By default sentences are NOT set as fuzzy.")
    )
    parser.add_argument(
        '--recursive',
        action='store_true',
        default=False,
        help=("If this option is used, wmlxgettext will scan recursively the "
              "directory set by the '--directory' parameter, and check "
              "every WML/Lua file. "
              "If this option is used, EXPLICIT LIST of files will be "
              "ignored.")
    )
    parser.add_argument(
        'filelist',
        help='List of WML/Lua files of your UMC (source files).',
        nargs='*'
    )

    '''
    Developer Options - not suitable for standard usage:
    --DMode is a reserved flag used to verify how wmlxgettext is internally
            working. When this flag is used (set to ON), an extra
            file (debug.txt) will be created. debug.txt will contain
            useful information to check if wmlxgettext is working as expected
            (but make sense only for wmlxgettext developers/contributors)
    '''
    parser.add_argument(
        '--DMode',
        action='store_true',
        dest='debugmode',
        default=False,
        help=argparse.SUPPRESS
    )

    return parser.parse_args(args)



class AnalysisTooNarrowException(Exception):
    pass

def extractor(files, fileref_root, offset = 0):
    for fileno, fx in enumerate(files):
        if fileno < offset:
            continue

        fname = os.path.normpath(os.path.join(fileref_root, fx))
        is_file = os.path.isfile(fname)
        if is_file:
            infile = None
            try:
                infile = open(fname, 'r', encoding="utf-8")
            except OSError as e:
                errmsg = 'cannot read file: ' + e.args[1]
                pywmlx.wmlerr(e.filename, errmsg, OSError)
            if fname.lower().endswith('.cfg'):
                pywmlx.statemachine.run(filebuf=infile, fileref=fx,
                            fileno=fileno, startstate='wml_idle', waitwml=True)
            if fname.lower().endswith('.lua'):
                pywmlx.statemachine.run(filebuf=infile, fileref=fx,
                            fileno=fileno, startstate='lua_idle', waitwml=False)
            infile.close()



def handle_macro_po_sentences(sentlist, po_sentences, start_path="", fileref_root="", outfile=None, fuzzy=False):
    # In fact, Wesnoth's engine expands macros in the preprocessor step.
    # Therefore, the input below ran through wmlxgettext should output
    #
    # msgid "Hello, world."
    # msgstr ""
    #
    # # define GREET MODE WHOM
    # [{MODE}]
    #     {MODE} = _ "Hello, {WHOM}."
    # [/{MODE}]
    # # enddef
    #
    # {GREET message world}
    #
    # To accomplish that through all macro calls and subcalls, we identify
    # three types of macro calls according to their context.
    # A. Inside translatable strings.
    # B. Inside macro definitions, but not inside a string.
    # C. Every other macro call (top level).
    #
    # The simplest case is that macro type A is called directly by
    # a single macro type C. In that case, we:
    # 1. Identify the parameter index "n" in the definition of macro C,
    #    associated with the call of macro A.
    # 2. Substitute the nth parameter of macro C into the string containing
    #    macro call A.
    #
    # There are several factors that complicate it:
    # 1. There may be one or more macros of type B. We need to track their
    #    parameters as well.
    # 2. There may be more than one macro of type C. Each of them represents
    #    a new string in the output.
    # 3. It's possible the parameters of macro(s) type B and C aren't a 1:1
    #    match.
    # 4. Since Wesnoth 1.13.7, named optional macro parameters are available.
    #    through the directive #arg
    # 5. Macros may be deleted with #undef and later redefined.
    #
    # For example, let
    #
    # # define MOODY_GREET MODE QUALIFIER WHOM
    #   {GREET {MODE} (very {QUALIFIER} {WHOM})}
    # # enddef
    #
    # {MOODY_GREET message good world}
    # {MOODY_GREET message bad world}
    #
    # We know that GREET's relevant parameter is the second, and it's affected by
    # the second and third parameters of MOODY_GREET. Fortunately, MOODY_GREET has
    # a finite universe of possible parameters, so we iterate through all of them,
    # and we get
    #
    # msgid "Hello, very good world."
    # msgstr ""
    #
    # msgid "Hello, very bad world."
    # msgstr ""
    #
    # Note that $substitutions are bad practice for localizable strings,
    # as the translator will only be able to relocate the variable, and not
    # act according to their possible values. Many languages have lots of
    # conditional declensions, which warrant exhausting all combinations.
    # Those *are* provided by macros.
    #
    #
    # Strategy:
    # 1. Identify all strings which require preprocessing, as well as their
    #    reference (file name, line number), and parent macro definition.
    #    These are passed to handle_macro_po_sentences.
    #
    # 2. Use wmltools3.CrossRef to parse macro definitions and callsites.
    #    2.1 Note whether there's an #undef in the same file (i.e whether
    #        the macro is local or global).
    #    2.2. If any of the macros from (1) is non-local, fall back to (3).
    #    2.3. Otherwise, go to (4).
    #
    # 3. Use wmltools3.CrossRef to parse macro definitions and callsites on the entire addon.
    #    3.1. Note whether the macro contains quote marks or is multiline (error out if so.)
    #    3.2. Go to (4).
    #
    # 4. Deeply identify all macro callsites with expansions that include
    #    strings in (1).
    # 5. Propagate macro parameters.
    # 6. Evaluate macro expansions.
    #
    ctx_macros = {}
    ids_by_sentence = {}
    asts_by_sentence = {}
    (sentences_by_file, sentences_by_macro) = po_sentences
    for fileref, sentences in sentences_by_file.items():
        for posentence in sentences:
            lone_identifiers, complex_identifiers = set(), set()
            # Fill-in lone_identifiers, complex_identifiers
            ast = AST.parse_sentence_and_ids(posentence.sentence, lone_identifiers, complex_identifiers)
            macro = Macro(*posentence.macro)
            asts_by_sentence[posentence.sentence] = ast
            ids_by_sentence[posentence.sentence] = (lone_identifiers, complex_identifiers)
            if macro.name is not None: ctx_macros[macro] = True

    args_by_macro = {}
    xrefs_by_file = {}
    xrefs_all = None

    def resolve_strings_at(dirpath=None, single_file=None):
        nonlocal xrefs_all

        if dirpath is None:
            # 2. Use wmltools3.CrossRef to parse macro definitions and callsites.
            filelist = [os.path.normpath(os.path.join(fileref_root, single_file))]
            xrefs = CrossRef(filelist=filelist)
            xrefs_by_file[filelist[0]] = xrefs # filelist[0] abs path
        else:
            # 3. Use wmltools3.CrossRef to parse macro definitions and callsites on the entire addon.
            xrefs = CrossRef(dirpath=dirpath)
            xrefs_all = xrefs

        for macro in ctx_macros:
            if macro.name is None:
                # Outside any macro definitions.
                continue
            if single_file and macro.fileref != single_file:
                # Ignore in single-file analysis
                continue

            # print("Tracing %s..." % macro, file=sys.stderr)
            xref = macro.to_abs(fileref_root).get_ref(xrefs)
            assert xref is not None, ("Macro %s not referenced" % macro)

            is_local = xref.undef is not None
            if not is_local and single_file is not None:
                # 2.1 Note whether there's an #undef in the same file (i.e whether
                #     the macro is local or global).
                # 2.2. If any of the macros from (1) is non-local, fall back to (3).
                raise AnalysisTooNarrowException("Macro %s is exported." % macro)

            contained_sentences = sentences_by_macro[macro]

            # Intermediate values in extraction of parameters and macros
            # used by translatable sentences.

            # lone identifiers    : list<set<string>>
            all_params_sets = [ids_by_sentence[s.sentence][0] for s in contained_sentences]
            # complex identifiers : list<set<string>>
            complex_id_sets = [ids_by_sentence[s.sentence][1] for s in contained_sentences]
            # maybe_parameters    : set<str>
            maybe_parameters = set.union(*all_params_sets)

            # parameters: set<str>
            # Use set to ease look-up when using them as filter.
            parameters = set(id for id in maybe_parameters if id in xref.args or id in xref.optional_args)

            # We will need to iterate over constant_macros and variable_macros.
            # Note that it's possible for a macro with optional arguments to be listed in both.

            # macro names with 0 arguments : set<str>
            constant_macros = maybe_parameters.difference(parameters)
            # macro names with 1+ arguments: set<str>
            variable_macros = set.union(*complex_id_sets)

            for callee_name in set.union(constant_macros, variable_macros):
                if callee_name in GlobalWMLMacros:
                    continue
                if not callee_name in xrefs.xref:
                    if single_file is None:
                        print("Unknown macro {%s} called by %s. Strings using it will not be translated." % (callee_name, macro), file=sys.stderr)
                    else:
                        raise AnalysisTooNarrowException("Macro {%s} not found at %s." % (callee_name, single_file))
                if not any(map(ReferenceHelper.is_embeddable_macro, xrefs.xref[callee_name])):
                    if single_file is None:
                        print("No valid embeddable expansion for macro {%s} called by %s. Strings using it will not be translated." % (callee_name, macro), file=sys.stderr)
                    else:
                        raise AnalysisTooNarrowException("No valid definition for macro {%s} found at %s." % (callee_name, single_file))

            args_variants = ReferenceHelper.get_arguments(xref, xrefs, parameters)
            if len(args_variants) != 0:
                # 4. Deeply identify all macro callsites with expansions that include
                #    strings in (1).
                # 5. Propagate macro parameters.
                ReferenceHelper.deep_replace_arguments(args_variants, xrefs)

            args_by_macro[macro] = args_variants

    try:
        for fileref in sentences_by_file:
            resolve_strings_at(dirpath=None, single_file=fileref)
    except AnalysisTooNarrowException as ex:
        print("%s Falling back to full-tree analysis." % ex.args, file=sys.stderr)
        try:
            resolve_strings_at(dirpath=[start_path])
        except Exception as ex:
            # Remove the trace for AnalysisTooNarrowException.
            raise ex from None


    # 2.3. Otherwise, go to (4).
    # 3.3. Go to (4).
    new_sentences = {}
    for macro, sentences in sentences_by_macro.items():
        args_variants = args_by_macro[macro] if macro in args_by_macro else []
        file_path_abs = os.path.normpath(os.path.join(fileref_root, macro[1]))
        xrefs = xrefs_by_file[file_path_abs] if file_path_abs in xrefs_by_file else xrefs_all
        for po_sentence in sentences:
            ast = asts_by_sentence[po_sentence.sentence]
            # print("raw sentence: (%s <-> %s)" % (po_sentence.sentence, ast), file=sys.stderr)

            # 5. Propagate macro parameters.
            # sub_sentences: list<(str, Macro|NoneType)>
            sub_sentences = []

            if len(ids_by_sentence[po_sentence.sentence][0]) > 0:
                # No lone_identifiers -> No parameters
                # Only evaluate parameters if there is at least one lone identifier.
                sub_sentences = AST.evaluate_many_on_one(ast, args_variants)

            if len(sub_sentences) == 0:
                # Ensure loop runs at least once
                sub_sentences.append((po_sentence.sentence, None))

            for sentence_after_args, ctx in sub_sentences:
                used_macros = set()
                ast = AST.parse_sentence_and_ids(sentence_after_args, used_macros, used_macros)
                # print("sentence after args: (%s <-> %s)" % (sentence_after_args, ast), file=sys.stderr)

                # 6. Evaluate macro expansions.
                # macro_replacements: list<(Reference|ReferenceLike, True, None)>
                macro_replacements = []
                if len(used_macros) > 0:
                    valid_macros = CrossRefHelper.get_valid_macros(used_macros, xrefs)
                    macro_replacements = CrossRefHelper.get_macro_variants(valid_macros, xrefs)
                    CrossRefHelper.deep_replace_macros(sentence_after_args, macro_replacements, xrefs)

                if len(macro_replacements) == 0:
                    # Ensure loop runs at least once
                    macro_replacements.append(({}, None, sentence_after_args))
                for defs, ended, sentence_after_macro in macro_replacements:
                    # print("sentence after macro: %s" % sentence_after_macro, file=sys.stderr)
                    # assert(isinstance(ctx, Macro|NoneType))
                    po_sentence_variant = copy(po_sentence)
                    po_sentence_variant.finfos = copy(po_sentence_variant.finfos)
                    po_sentence_variant.sentence = sentence_after_macro
                    if '\x01' + po_sentence_variant.sentence in sentlist:
                        # print("Ignored ref to raw sentence %s" % po_sentence_variant.sentence, file=sys.stderr)
                        # Output has already been written. TODO: FIXME?
                        # sentlist['\x01' + po_sentence_variant.sentence].update_with_commented_string(po_sentence_variant)
                        pass
                    elif po_sentence_variant.sentence in new_sentences:
                        # print("New ref in processed sentence %s" % po_sentence_variant.sentence, file=sys.stderr)
                        new_sentences[po_sentence_variant.sentence].update_with_commented_string(po_sentence_variant)
                    else:
                        # print("New sentence %s" % po_sentence_variant.sentence, file=sys.stderr)
                        new_sentences[po_sentence_variant.sentence] = po_sentence_variant

    for posentence in new_sentences.values():
        posentence.write(outfile, fuzzy)
        print('', file=outfile)


def main():
    signal.signal(signal.SIGINT, sigint_handler)
    args = commandline(sys.argv[1:])
    pywmlx.ansi_setEnabled(args.text_col)
    pywmlx.wincol_setEnabled(args.text_col)
    pywmlx.set_warnall(args.warnall)
    startPath = os.path.realpath(os.path.normpath(args.start_path))
    fileref_root = startPath
    sentlist = dict()
    fdebug = None
    if args.folder == '-':
        args.folder = None
    if args.debugmode:
        fdebug = open('debug.txt', 'w', encoding='utf-8')
    pywmlx.statemachine.setup(sentlist, args.initdom, args.domain,
                              args.warnall, fdebug)
    if args.recursive is False and args.filelist is None:
        pywmlx.wmlerr("bad command line", "FILELIST must not be empty. "
               "Please, run wmlxgettext again and, this time, add some file "
               "in FILELIST or use the --recursive option.")
    elif args.recursive is False and len(args.filelist) <= 0:
        pywmlx.wmlerr("bad command line", "FILELIST must not be empty. "
               "Please, run wmlxgettext again and, this time, add some file "
               "in FILELIST or use the --recursive option.")
    elif args.recursive is False:
        filelist = args.filelist
    # the following elif case implicitly expects that args.recursive is True
    elif args.filelist is not None:
        if len(args.filelist) > 0:
            pywmlx.wmlwarn("command line warning", "Option --recursive was "
                "used, but FILELIST is not empty. All extra file listed in "
                "FILELIST will be ignored.")
        # If we use the --recursive option we recursively scan the add-on
        # directory.
        #    But we want that the file reference informations placed
        # in the .po file will remember the (relative) root name of the
        # addon.
        #    This is why the autof.autoscan function returns a tuple of
        # values:
        #   the first one is the parent directory of the original startPath
        #   the second one is the filelist (with the "fixed" file references)
        fileref_root, filelist = pywmlx.autof.autoscan(startPath)
    # this last case is equal to:
    # if args.recursive is True and args.filelist is None:
    else:
        fileref_root, filelist = pywmlx.autof.autoscan(startPath)
    if args.sort_by_file:
        filelist.sort()

    extractor(filelist, fileref_root)

    folder = None
    filename = None
    outfile = sys.stdout
    now = datetime.utcnow()
    cdate = '{:04d}-{:02d}-{:02d} {:02d}:{:02d} UTC\\n"'.format(now.year, now.month, now.day, now.hour, now.minute)
    if args.folder is not None:
        folder = os.path.realpath(os.path.normpath(args.folder))
        if not os.path.isdir(folder) and "." in os.path.basename(folder):
            # Back-compat
            folder, filename = os.path.split(folder)
        os.makedirs(folder, exist_ok=True)

    for domain, catalog in sentlist.items():
        if folder is not None:
            try:
                outfile = open(os.path.join(folder, "{}.pot".format(domain) if filename is None else filename), 'w', encoding="utf-8")
            except OSError as e:
                errmsg = 'cannot write file: ' + e.args[1]
                pywmlx.wmlerr(e.filename, errmsg, OSError)
        pkgversion = args.package_version + '\\n"'
        print('msgid ""\nmsgstr ""', file=outfile)
        print('"Project-Id-Version:', pkgversion, file=outfile)
        print('"Report-Msgid-Bugs-To: https://bugs.wesnoth.org/\\n"', file=outfile)
        print('"POT-Creation-Date:', cdate, file=outfile)
        print('"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n"', file=outfile)
        print('"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"', file=outfile)
        print('"Language-Team: LANGUAGE <LL@li.org>\\n"', file=outfile)
        print('"MIME-Version: 1.0\\n"', file=outfile)
        print('"Content-Type: text/plain; charset=UTF-8\\n"', file=outfile)
        print('"Content-Transfer-Encoding: 8bit\\n"\n', file=outfile)

        sentences_wmacro_by_file = {}
        sentences_wmacro_by_macro = {}
        macro_po_sentences = (sentences_wmacro_by_file, sentences_wmacro_by_macro)
        for posentence in sorted(catalog.values(), key=lambda x: x.orderid):
            macro = posentence.macro
            if macro is None:
                posentence.write(outfile, args.fuzzy)
                print('', file=outfile)
            else:
                # 1. Identify all strings which require preprocessing, as well as their
                #    reference (file name, line number), and parent macro definition.
                #    These are passed to handle_macro_po_sentences.
                if not macro[1] in sentences_wmacro_by_file:
                    sentences_wmacro_by_file[macro[1]] = []
                sentences_wmacro_by_file[macro[1]].append(posentence)
                if not macro in sentences_wmacro_by_macro:
                    sentences_wmacro_by_macro[macro] = []
                sentences_wmacro_by_macro[macro].append(posentence)

        if len(sentences_wmacro_by_file) > 0:
            print("Translatable strings with macros found in %d files." % len(sentences_wmacro_by_file), file=sys.stderr)
            handle_macro_po_sentences(catalog, macro_po_sentences, start_path=startPath, fileref_root=fileref_root, outfile=outfile, fuzzy=args.fuzzy)

        if args.folder is not None:
            outfile.close()
        if args.debugmode:
            fdebug.close()



def sigint_handler(signal, frame):
    """This function defines what happens when the SIGINT signal is encountered by pressing ctrl-c during runtime.
    When ctrl-c is pressed, a one-line message is displayed and Python exits with Status 1.
    This overrides Python's default behavior of displaying a traceback when ctrl-c is pressed.
    """
    print ('Aborted by pressing ctrl-c')
    sys.exit(1)



if __name__ == "__main__":
    main()
