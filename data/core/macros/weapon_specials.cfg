#textdomain wesnoth-help
# Weapon special macros to be included in the SingleWML description of a unit.

#define WEAPON_SPECIAL_UNWIELDY
    [disable]
        id=unwieldy
        name=_"unwieldy"
        description=_"This attack can only be used offensively."
        active_on=defense
        special_note=_ "This unit has an unwieldy weapon, which cannot be used defensively."
    [/disable]
#enddef

#define WEAPON_SPECIAL_BERSERK
    # Canned definition of the Berserk ability to be included in a
    # [specials] clause.
    [berserk]
        id=berserk
        name= _ "berserk"
        description= _ "Whether used offensively or defensively, this attack presses the engagement until one of the combatants is slain, or 30 rounds of attacks have occurred."
        special_note={INTERNAL:SPECIAL_NOTES_BERSERK}
        value=30
    [/berserk]
#enddef

#define WEAPON_SPECIAL_BACKSTAB
    # Canned definition of the Backstab ability to be included in a
    # [specials] clause.
    [damage]
        id=backstab
        name= _ "backstab"
        description= _ "When used offensively, this attack deals double damage if there is an enemy of the target on the opposite side of the target, and that unit is not incapacitated (turned to stone or otherwise paralyzed)."
        special_note={INTERNAL:SPECIAL_NOTES_BACKSTAB}
        multiply=2
        active_on=offense
        [filter_opponent]
            formula="
                enemy_of(self, flanker) and not flanker.petrified
            where
                flanker = unit_at(direction_from(loc, other.facing))
            "
        [/filter_opponent]
    [/damage]
#enddef

#define WEAPON_SPECIAL_PLAGUE_TYPE TYPE
    # Canned definition of the Plague ability to be included in a
    # [specials] clause (with type specifier).
    # `$type` is the only available gettext variable and contains the type of the unit spawned
    # by this plague effect. It will be substituted in `name` and `description` only.
    [plague]
        id=plague({TYPE})
        name= _ "plague ($type)"
        description= _ "When a unit is killed by a Plague attack, that unit is replaced with a $type on the same side as the unit with the Plague attack. This doesn’t work on Undead or units in villages."
        special_note={INTERNAL:SPECIAL_NOTES_PLAGUE}
        type={TYPE}
    [/plague]
#enddef

#define WEAPON_SPECIAL_PLAGUE
    # Canned definition of the Plague ability to be included in a
    # [specials] clause.
    # $type is the only available gettext variable and contains the type of the unit spawned
    # by this plague effect. It will be substituted in `name` and `description` only.
    # In this case, `$type = Walking Corpse`.
    [plague]
        id=plague
        name= _ "plague"
        description= _ "When a unit is killed by a Plague attack, that unit is replaced with a Walking Corpse on the same side as the unit with the Plague attack. This doesn’t work on Undead or units in villages."
        special_note={INTERNAL:SPECIAL_NOTES_PLAGUE}
        type=Walking Corpse
    [/plague]
#enddef

#define WEAPON_SPECIAL_SLOW
    # Canned definition of the Slow ability to be included in a
    # [specials] clause.
    [slow]
        id=slow
        name= _ "slows"
        description= _ "This attack slows the target until it ends a turn. Slow halves the damage caused by attacks and the movement cost for a slowed unit is doubled. A unit that is slowed will feature a snail icon in its sidebar information when it is selected."
        special_note={INTERNAL:SPECIAL_NOTES_SLOW}
    [/slow]
#enddef

#define WEAPON_SPECIAL_PETRIFY
    # Canned definition of the Petrify ability to be included in a
    # [specials] clause.
    [petrifies]
        id=petrifies
        name= _ "petrifies"
        description= _ "This attack petrifies the target, turning it to stone. Units that have been petrified may not move or attack."
        special_note={INTERNAL:SPECIAL_NOTES_PETRIFY}
    [/petrifies]
#enddef

#define WEAPON_SPECIAL_MARKSMAN
    # Canned definition of the Marksman ability to be included in a
    # [specials] clause.
    [chance_to_hit]
        id=marksman
        name= _ "marksman"
        description= _ "When used offensively, this attack always has at least a 60% chance to hit."
        special_note={INTERNAL:SPECIAL_NOTES_MARKSMAN}
        value=60
        cumulative=yes
        active_on=offense
    [/chance_to_hit]
#enddef

#define WEAPON_SPECIAL_MAGICAL
    # Canned definition of the Magical (targeting) ability to be included in a
    # [specials] clause.
    [chance_to_hit]
        id=magical
        name= _ "magical"
        description= _ "This attack always has a 70% chance to hit regardless of the defensive ability of the unit being attacked."
        special_note={INTERNAL:SPECIAL_NOTES_MAGICAL}
        value=70
        cumulative=no
    [/chance_to_hit]
#enddef

#define WEAPON_SPECIAL_NAVAL_RAM
    # Canned definition of the Naval Ram ability to be included in a
    # [specials] clause.
    [disable]
        id=naval_ram
        name=_"naval ram"
        description=_"This attack can only be used against units in water terrain."
        [filter_opponent]
            [filter_location]
                [not]
                    terrain="W*,S*"
                [/not]
            [/filter_location]
        [/filter_opponent]
        special_note=_ "This unit has an attack that can only be used against units in watery terrain."
    [/disable]
    [damage]
        id=charge
        name= _ "charge"
        description= _ "When used offensively, this attack deals double damage to the target. It also causes this unit to take double damage from the target’s counterattack."
        special_note={INTERNAL:SPECIAL_NOTES_CHARGE}
        multiply=2
        apply_to=both
        active_on=offense
    [/damage]
#enddef

#define WEAPON_SPECIAL_HONED
    # Canned definition of the Honed ability to be included in a
    # [specials] clause.
    [chance_to_hit]
        id=honed
        name= _ "honed"
        description= _ "This attack is 10% more accurate than other attacks."
        special_note= _ "This unit’s “honed” attack is slightly more accurate than other attacks."
        add=10
        cumulative=yes
    [/chance_to_hit]
#enddef

#define WEAPON_SPECIAL_SWARM
    # Canned definition of the Swarm ability to be included in a
    # [specials] clause.
    [swarm]
        id=swarm
        name= _ "swarm"
        description= _ "The number of strikes of this attack decreases when the unit is wounded. The number of strikes is proportional to the percentage of its of maximum HP the unit has. For example a unit with 3/4 of its maximum HP will get 3/4 of the number of strikes."
        special_note={INTERNAL:SPECIAL_NOTES_SWARM}
    [/swarm]
#enddef

#define WEAPON_SPECIAL_CHARGE
    # Canned definition of the Charge ability to be included in a
    # [specials] clause.
    [damage]
        id=charge
        name= _ "charge"
        description= _ "When used offensively, this attack deals double damage to the target. It also causes this unit to take double damage from the target’s counterattack."
        special_note={INTERNAL:SPECIAL_NOTES_CHARGE}
        multiply=2
        apply_to=both
        active_on=offense
    [/damage]
#enddef

#define WEAPON_SPECIAL_GUARD
    # Canned definition of the Guard ability to be included in a
    # [specials] clause.
    [damage]
        id=guard
        name= _ "guard"
        description= _ "This attack blocks half of the damage from its target’s strikes."
        special_note= _ "This unit’s guarding attack can halve incoming damage, but only when used in combat."
        multiply=0.5
        apply_to=opponent
    [/damage]
#enddef

#define WEAPON_SPECIAL_DRAIN
    # Canned definition of the Drain ability to be included in a
    # [specials] clause.
    [drains]
        id=drains
        name= _ "drains"
        description= _ "This unit drains health from living units, healing itself for half the amount of damage it deals (rounded down)."
        special_note={INTERNAL:SPECIAL_NOTES_DRAIN}
    [/drains]
#enddef

#define WEAPON_SPECIAL_FIRSTSTRIKE
    # Canned definition of the First-strike ability to be included in a
    # [specials] clause.
    [firststrike]
        id=firststrike
        name= _ "first strike"
        description= _ "This unit always strikes first with this attack, even if they are defending."
        special_note={INTERNAL:SPECIAL_NOTES_FIRSTSTRIKE}
    [/firststrike]
#enddef

#define WEAPON_SPECIAL_POISON
    # Canned definition of the Poison ability to be included in a
    # [specials] clause.
    [poison]
        id=poison
        name= _ "poison"
        description= _ "This attack poisons living targets. Poisoned units lose 8 HP every turn until they are cured or are reduced to 1 HP. Poison cannot, of itself, kill a unit."
        special_note={INTERNAL:SPECIAL_NOTES_POISON}
    [/poison]
#enddef

#define WEAPON_SPECIAL_STUN
    # Canned definition of the Stun ability to be included in a
    # [specials] clause.
    [stun]
        id=stun
        name= _ "stun"
        description= _ "This attack hits so hard that the opponent is dazed and can no longer enforce a zone of control. The effect wears off on the opponent’s next turn."
        special_note=_ "This unit is able to stun its enemies, disrupting their zones of control."
    [/stun]
#enddef

#define WEAPON_SPECIAL_ARCANE
    # Canned definition of the Arcane ability to be included in a
    # [specials] clause.
    [damage_type]
        id=arcane_damage
        name= _ "arcane"
        description= _ "This attack combines the arcane type with the type of weapon used so that resistance to the arcane type does not penalize the user."
        special_note=_ "This unit can use the arcane type when the opponent is particularly sensitive to it in relation to the weapon on which it is applied."
        alternative_type=arcane
    [/damage_type]
#enddef

#define WEAPON_SPECIAL_INTERCEPT
    [extra_attack]#I think it's a good idea to call abilities which launch extra attacks (even if without combat XP) [attack]
        id=intercept
        name= _ "intercept"
        female_name= _ "intercept"
        description=_ "When an enemy moves adjacent to this unit, the wielder immediately makes a single intercepting strike using this weapon. This attack occurs before the enemy can act and uses only one strike regardless of the weapon's normal number of attacks."
        special_note=_ "Delivers one strike to enemies moving adjacent."
        [filter_self] #so this shows as inactive in combat preview, since the ability doesn't affect regular combat at all
            [not]
            [/not]
        [/filter_self]
        {WEAPON_SPECIAL_INTERCEPT_EVENT}
    [/extra_attack]
#enddef

#define WEAPON_SPECIAL_INTERCEPT_EVENT
    [event]
        name=side turn
        first_time_only=no
        id=weapon_special_intercept_used
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({side=wml.variables["side_number"],{"and",{{"has_attack",{special_id = "intercept"}}}}})
for _,u in ipairs(units) do
    u.variables.intercept_used = false
end
>>
        [/lua]
    [/event]
     [event]
        name=recruit,recall
        id=weapon_special_intercept_recharge
        first_time_only=no
        [filter]
            formula="self.wml_vars.intercept_used = true"
        [/filter]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
u.variables.intercept_used = false
>>
        [/lua]
    [/event]
    [event]
        name = enter_hex
        id = intercept_weapon_special_event
        first_time_only = no
        [filter]
            [filter_adjacent]
                [has_attack]
                    special_id = intercept
                [/has_attack]
                is_enemy = yes
            [/filter_adjacent]
        [/filter]
        [lua]
            code=<<
--attacker is e
--defender is u
local _ = wesnoth.textdomain "wesnoth-Bandits_from_Brown_Hills"
local x1 = wesnoth.current.event_context.x1
local y1 = wesnoth.current.event_context.y1
local u = wesnoth.units.get(x1,y1)
local animator,sheath_weapon = wesnoth.units.create_animator(),wesnoth.units.create_animator(),wesnoth.units.create_animator()
local enemies = wesnoth.units.find_on_map({{"filter_adjacent",{id=u.id, is_enemy = true}},{"has_attack",{special_id = "intercept"}},{"not",{{"filter_wml",{{"variables",{intercept_used=true}}}}}}}))
for iter,e in ipairs(enemies) do
    e.variables.intercept_used = true
    local i = 1
    while e.attacks[i] ~= nil do
        local weapon = wml.find_child(e.attacks[i].specials,{id="intercept"})
        if weapon ~= nil then
            break
        end
        i = i + 1
    end
    local attacking_weapon=i
    local loc = e.loc
    local loc2 = u.loc
    local unused, unused, e_stats, u_stats = wesnoth.simulate_combat(e,attacking_weapon, u)-- -- THIS IF I'd want defensive specials of weapon to apply, but enemy doesn't fight back, so no specials should take effect
    local w = e.attacks[attacking_weapon]
    local w2 = nil
    local w2_cfg=nil
    if u_stats.name ~= nil then
        w2 = u.attacks[u_stats.name]
        w2_cfg = w2.__cfg
    end
    e.facing=wesnoth.map.get_relative_dir(e.x, e.y, u.x, u.y) --doesn't work if unit has no animation for the draw...
    animator:add(e, "draw_weapon", "hit",{with_bars = true, primary = w, secondary = w2})
    sheath_weapon:add(e, "sheath_weapon", "hit",{with_bars = true, primary = w, secondary = w2})
    if iter == 1 then --when drawing weapons u is already looking towards first e
        u.facing=wesnoth.map.get_relative_dir(u.x, u.y,e.x, e.y)
        animator:add(u, "draw_weapon", "hit",{with_bars = true, primary = w, secondary = w2})
        sheath_weapon:add(u, "sheath_weapon", "hit",{with_bars = true, primary = w, secondary = w2})
    end
end
animator:run()
animator:clear()
for iter,e in ipairs(enemies) do
    local i = 1
    while e.attacks[i] ~= nil do
        local weapon = wml.find_child(e.attacks[i].specials,{id="intercept"})
        if weapon ~= nil then
            break
        end
        i = i + 1
    end
    local attacking_weapon=i
    e.facing=wesnoth.map.get_relative_dir(e.x, e.y, u.x, u.y)
    u.facing=wesnoth.map.get_relative_dir(u.x, u.y,e.x, e.y)
    -- u.attacks[e.variables.us_weapon] = {movement_used=100000,attacks_used=1}
    local loc = e.loc
    local loc2 = u.loc
    local unused, unused, e_stats, u_stats = wesnoth.simulate_combat(e,attacking_weapon, u)-- -- THIS IF I'd want defensive specials of weapon to apply, but enemy doesn't fight back, so no specials should take effect
    local w = e.attacks[attacking_weapon]
    local w2 = nil
    local w2_cfg=nil
    if u_stats.name ~= nil then
        w2 = u.attacks[u_stats.name]
        w2_cfg = w2.__cfg
    end
    if mathx.random() < (e_stats.chance_to_hit/100) then

        local damage_inflicted = math.floor(e_stats.damage)

        local drain = 0
        if e_stats.drains then
            drain = math.floor(math.min((math.min(damage_inflicted,u.hitpoints) * e_stats.drain_percent / 100) + e_stats.drain_constant, math.max(e.max_hitpoints - e.hitpoints,0)))
        end
        local text = ""
        if drain ~= 0 then
            text = text..drain
        end

        local text2 =  damage_inflicted.."\n"
        local add_tab = false
        local gender = u.gender
        local statuses = {}

        local function set_status(ability, name, male_string, female_string, sound)
            if not e_stats[ability] or u.status[name] then return end
            if gender == "female" then
                text2 = string.format("%s%s%s", text2, tostring(female_string), "\n")
            else
                text2 = string.format("%s%s%s", text2, tostring(male_string), "\n")
            end

            statuses[#statuses+1]=name
            add_tab = true

            if sound then -- for unhealable, that has no sound
                wesnoth.audio.play(sound)
            end
        end
        if not u.status.unpoisonable then
            set_status("poisons","poisoned", _"poisoned", _"female^poisoned", "poison.ogg")
        end
        set_status("slows","slowed", _"slowed", _"female^slowed", "slowed.wav")
        set_status("petrifies","petrified", _"petrified", _"female^petrified", "petrified.ogg")
        if add_tab then
            text2 = string.format("%s%s", "     ", text2)
        end

        animator:add(e, "attack", "hit",{with_bars = true, primary = w, secondary = w2, text = text,color={0,255,0}})
        animator:add(u, "defend", "hit",{with_bars = true, primary = w, secondary = w2, text = text2,color={255,0,0}})
        animator:run()
        animator:clear()
        for i=1, #statuses do
            u.status[statuses[i]] = true
        end
        e.hitpoints=(e.hitpoints + drain)
        u.hitpoints=(u.hitpoints - e_stats.damage)
        wesnoth.game_events.fire("attacker_hits", e.loc, u.loc, {{"first",w.__cfg},{"second",w2_cfg},damage_inflicted=damage_inflicted})
        if u.valid == nil or u.hitpoints <= 0 then
            sheath_weapon:run()
            wesnoth.game_events.fire("attack end", u.loc, loc2, {{"first",wml.get_child(wesnoth.current.event_context,"weapon")},{"second",wml.get_child(wesnoth.current.event_context,"second_weapon")}})
            if u.valid == nil then
                --u doesn't exist PROPPER DEATH EVENTS should be fired already, by some other code (modders thing)
                break
            end
            wesnoth.game_events.fire("last breath", loc2, e.loc, {{"first",w2_cfg},{"second",w.__cfg}}) --inverted
            animator:add(u, "death", "hit",{with_bars = false, primary = w2, secondary = w}) --inverted
            animator:run()
            animator:clear()
            u_level = u.level
            u_id= u.id
            wesnoth.game_events.fire("die", u.loc, e.loc, {{"first",w2_cfg},{"second",w.__cfg}}) --inverted
            wesnoth.wml_actions.kill({ id = u_id, animate = false, fire_event = false})
            if u_level == 0 then
                e.experience = wesnoth.game_config.kill_experience * 0.5
                e:advance(true,true)
            else
                e.experience = e.experience +(u_level * wesnoth.game_config.kill_experience)
                e:advance(true,true)
            end
            -- TODO doesn't work for berserker (not intended, just a warning for future me), untested with plague
            break
        end
    else
        animator:add(e, "attack", "miss",{with_bars = true, primary = w, secondary = w2})
        animator:add(u, "defend", "miss",{with_bars = true, primary = w2, secondary = w})--inverted
        animator:run()
        animator:clear()
        wesnoth.game_events.fire("attacker_misses", e.loc, u.loc, {{"first",w.__cfg},{"second",w2_cfg}})
    end
end
sheath_weapon:run()
>>
        [/lua]
    [/event]

    #following code is solely to highlight hexes that can be attacked by the weapon special
    #this event is necessary to add the logic normally added by preload event when those events are first added into the game
    #preload must be used to make lua code save/load safe, but will not trigger if it only gets added when unit with this ability first appears in the game
    [event]
        name = select
        first_time_only = yes
        [fire_event]
            id = init_intercept_halo
        [/fire_event]
    [/event]
    [event]
        name = preload
        id = init_intercept_halo
        first_time_only = no
        [lua]
            code=<<
local halo_id = "items/spear-javelin.png"
local current_halo_locations = {}
local last_selected_x = nil
local last_selected_y = nil

local function has_intercept_ability(unit) --helper function for filtering
    if unit.variables.intercept_used then
        return false
    end
    for _, attack in ipairs(unit.attacks) do
        for special_tag in wml.child_range(attack.specials,"attack") do
            if special_tag.id == "intercept" then
                return true
            end
        end
    end
    --TODO: maybe check if ability is active if necessary
    return false
end

local function clear_halo_locations(selected_hex_x, selected_hex_y) -- shared cleanup logic
    if next(current_halo_locations) ~= nil then --check if current_halo_locations is empty so that redraw is not unnecessarily called
        for _, loc in ipairs(current_halo_locations) do
            wesnoth.interface.remove_hex_overlay(loc[1], loc[2], halo_id)
        end
        current_halo_locations = {}
        return true
    end
    return false
end

--this has triple function:
--first it is a fallback in case on_mouse_button does not clear markers when it should (which has visual graphic bug, so on_mouse_button should remain)
--second it also adds markers when hovering over unit, since movement range also appears on mouseover, not just select
--third it clears markers that it itself places
local previous_on_mouse_move = wesnoth.game_events.on_mouse_move
wesnoth.game_events.on_mouse_move = function(x,y)
    local sx, sy = wesnoth.interface.get_selected_hex()
    local should_redraw = false
    if ((sx ~= last_selected_x) or (sy ~= last_selected_y)) and (last_selected_x ~= -1) then
        should_redraw = clear_halo_locations(sx, sy)
        last_selected_x = -1
        last_selected_y = -1
    end
    if x then
        local current_unit = wesnoth.units.get(x, y)
        if current_unit then
            local hexes_in_range = wesnoth.paths.find_reach(current_unit)
            for _, candidate_hex in ipairs(hexes_in_range) do
                local n, ne, se, s, sw, nw = wesnoth.map.get_adjacent_hexes(candidate_hex)
                for _, adjacent_hex in ipairs({n, ne, se, s, sw, nw}) do
                    local cx = adjacent_hex[1]
                    local cy = adjacent_hex[2]
                    local enemy_unit = wesnoth.units.get(cx, cy)
                    if enemy_unit and wesnoth.sides.is_enemy(enemy_unit.side, current_unit.side) and has_intercept_ability(enemy_unit) then
                        wesnoth.interface.add_hex_overlay(candidate_hex[1], candidate_hex[2], { image = halo_id })
                        table.insert(current_halo_locations, {candidate_hex[1], candidate_hex[2]})
                        last_selected_x = x
                        last_selected_y = y
                        should_redraw = true -- this optimization is making extracting shared code more difficult, but in theory not impossible
                    end
                end
            end
        end
    end
    if should_redraw then
        wml.fire("redraw")
    end
    return previous_on_mouse_move(x,y)
end

--this might in theory break the markers or other UI elements, but works for now as the first and primary method of cleaning up markers after deselecting a unit - relying only on on_mouse_move causes a visual glitch when deselecting unit
--if possible, should be replaced when some sort of deselect trigger is available
local previous_on_mouse_button = wesnoth.game_events.on_mouse_button
wesnoth.game_events.on_mouse_button = function(x,y,button,event)
    if event == "up" then
        local x, y = wesnoth.interface.get_selected_hex()
        if not x then
            if clear_halo_locations(x, y) then
                wml.fire("redraw")
            end
        end
    end
    return previous_on_mouse_button(x,y,button,event)
end

--this part is used to mark and hold markers when unit is selected (which happens before movement)
--might be potentially obsolete due to on_mouse_move, but should be less fault-prone in general
--it is also quite possible that this is duplicating halo markers from on_mouse_move, in which case it might be desirable to disable it or add a logic that prevents duplication (i.e. checking if current_halo_location already contains this hex)
wesnoth.game_events.add{
    name = 'select',
    id = 'intercept_add_graphic_markers_on_select',
    first_time_only = false,
    action = function()
        local x, y = wesnoth.interface.get_selected_hex()
        local should_redraw = clear_halo_locations(x,y)
        if x then
            local current_unit = wesnoth.units.get(x, y)
            if current_unit then
                local hexes_in_range = wesnoth.paths.find_reach(current_unit)

                for _, candidate_hex in ipairs(hexes_in_range) do
                    local n, ne, se, s, sw, nw = wesnoth.map.get_adjacent_hexes(candidate_hex)
                    for _, adjacent_hex in ipairs({n, ne, se, s, sw, nw}) do
                        local cx = adjacent_hex[1]
                        local cy = adjacent_hex[2]
                        local enemy_unit = wesnoth.units.get(cx, cy)
                        if enemy_unit and wesnoth.sides.is_enemy(enemy_unit.side, current_unit.side) and has_intercept_ability(enemy_unit) then
                            wesnoth.interface.add_hex_overlay(candidate_hex[1], candidate_hex[2], { image = halo_id })
                            table.insert(current_halo_locations, {candidate_hex[1], candidate_hex[2]})
                            last_selected_x = x
                            last_selected_y = y
                            should_redraw = true  -- this optimization is making extracting shared code more difficult, but in theory not impossible
                        end
                    end
                end
            end
        end
        if should_redraw then
            wml.fire("redraw")
        end
    end
}
>>
        [/lua]
    [/event]

#enddef
