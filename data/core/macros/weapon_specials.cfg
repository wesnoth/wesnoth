#textdomain wesnoth-help
# Weapon special macros to be included in the SingleWML description of a unit.

#define WEAPON_SPECIAL_UNWIELDY
    [disable]
        id=unwieldy
        name=_"unwieldy"
        description=_"This attack can only be used offensively."
        active_on=defense
        special_note=_ "This unit has an unwieldy weapon, which cannot be used defensively."
    [/disable]
#enddef

#define WEAPON_SPECIAL_BERSERK
    # Canned definition of the Berserk ability to be included in a
    # [specials] clause.
    [berserk]
        id=berserk
        name= _ "berserk"
        description= _ "Whether used offensively or defensively, this attack presses the engagement until one of the combatants is slain, or 30 rounds of attacks have occurred."
        special_note={INTERNAL:SPECIAL_NOTES_BERSERK}
        value=30
    [/berserk]
#enddef

#define WEAPON_SPECIAL_BACKSTAB
    # Canned definition of the Backstab ability to be included in a
    # [specials] clause.
    [damage]
        id=backstab
        name= _ "backstab"
        description= _ "When used offensively, this attack deals double damage if there is an enemy of the target on the opposite side of the target, and that unit is not incapacitated (turned to stone or otherwise paralyzed)."
        special_note={INTERNAL:SPECIAL_NOTES_BACKSTAB}
        multiply=2
        active_on=offense
        [filter_opponent]
            formula="
                enemy_of(self, flanker) and not flanker.petrified
            where
                flanker = unit_at(direction_from(loc, other.facing))
            "
        [/filter_opponent]
    [/damage]
#enddef

#define WEAPON_SPECIAL_PLAGUE_TYPE TYPE
    # Canned definition of the Plague ability to be included in a
    # [specials] clause (with type specifier).
    # `$type` is the only available gettext variable and contains the type of the unit spawned
    # by this plague effect. It will be substituted in `name` and `description` only.
    [plague]
        id=plague({TYPE})
        name= _ "plague ($type)"
        description= _ "When a unit is killed by a Plague attack, that unit is replaced with a $type on the same side as the unit with the Plague attack. This doesn’t work on Undead or units in villages."
        special_note={INTERNAL:SPECIAL_NOTES_PLAGUE}
        type={TYPE}
    [/plague]
#enddef

#define WEAPON_SPECIAL_PLAGUE
    # Canned definition of the Plague ability to be included in a
    # [specials] clause.
    # $type is the only available gettext variable and contains the type of the unit spawned
    # by this plague effect. It will be substituted in `name` and `description` only.
    # In this case, `$type = Walking Corpse`.
    [plague]
        id=plague
        name= _ "plague"
        description= _ "When a unit is killed by a Plague attack, that unit is replaced with a Walking Corpse on the same side as the unit with the Plague attack. This doesn’t work on Undead or units in villages."
        special_note={INTERNAL:SPECIAL_NOTES_PLAGUE}
        type=Walking Corpse
    [/plague]
#enddef

#define WEAPON_SPECIAL_SLOW
    # Canned definition of the Slow ability to be included in a
    # [specials] clause.
    [slow]
        id=slow
        name= _ "slows"
        description= _ "This attack slows the target until it ends a turn. Slow halves the damage caused by attacks and the movement cost for a slowed unit is doubled. A unit that is slowed will feature a snail icon in its sidebar information when it is selected."
        special_note={INTERNAL:SPECIAL_NOTES_SLOW}
    [/slow]
#enddef

#define WEAPON_SPECIAL_PETRIFY
    # Canned definition of the Petrify ability to be included in a
    # [specials] clause.
    [petrifies]
        id=petrifies
        name= _ "petrifies"
        description= _ "This attack petrifies the target, turning it to stone. Units that have been petrified may not move or attack."
        special_note={INTERNAL:SPECIAL_NOTES_PETRIFY}
    [/petrifies]
#enddef

#define WEAPON_SPECIAL_MARKSMAN
    # Canned definition of the Marksman ability to be included in a
    # [specials] clause.
    [chance_to_hit]
        id=marksman
        name= _ "marksman"
        description= _ "When used offensively, this attack always has at least a 60% chance to hit."
        special_note={INTERNAL:SPECIAL_NOTES_MARKSMAN}
        value=60
        cumulative=yes
        active_on=offense
    [/chance_to_hit]
#enddef

#define WEAPON_SPECIAL_MAGICAL
    # Canned definition of the Magical (targeting) ability to be included in a
    # [specials] clause.
    [chance_to_hit]
        id=magical
        name= _ "magical"
        description= _ "This attack always has a 70% chance to hit regardless of the defensive ability of the unit being attacked."
        special_note={INTERNAL:SPECIAL_NOTES_MAGICAL}
        value=70
        cumulative=no
    [/chance_to_hit]
#enddef

#define WEAPON_SPECIAL_NAVAL
    # Canned definition of the Naval Ram ability to be included in a
    # [specials] clause.
    [dummy]
        id=naval
        name=_"naval"
        description=_"This attack can only be used when both the attacker and the defender are in water or swamp."
        special_note=_ "This unit has an attack that can only be used when both the attacker and the defender are in water or swamp."
    [/dummy]
    [disable]
        [filter_self]
            [filter_location]
                [not]
                    terrain="W*^*,S*^*,Km*^*,Cm*^*,Chw^*,Chs^*"
                [/not]
            [/filter_location]
        [/filter_self]
    [/disable]
    [disable]
        [filter_opponent]
            [filter_location]
                [not]
                    terrain="W*^*,S*^*,Km*^*,Cm*^*,Chw^*,Chs^*"
                [/not]
            [/filter_location]
        [/filter_opponent]
    [/disable]
#enddef

#define WEAPON_SPECIAL_HONED
    # Canned definition of the Honed ability to be included in a
    # [specials] clause.
    [chance_to_hit]
        id=honed
        name= _ "honed"
        description= _ "This attack is 10% more accurate than other attacks."
        special_note= _ "This unit’s “honed” attack is slightly more accurate than other attacks."
        add=10
        priority=-10
    [/chance_to_hit]
#enddef

#define WEAPON_SPECIAL_SWARM
    # Canned definition of the Swarm ability to be included in a
    # [specials] clause.
    [swarm]
        id=swarm
        name= _ "swarm"
        description= _ "The number of strikes of this attack decreases when the unit is wounded. The number of strikes is proportional to the percentage of its of maximum HP the unit has. For example a unit with 3/4 of its maximum HP will get 3/4 of the number of strikes."
        special_note={INTERNAL:SPECIAL_NOTES_SWARM}
    [/swarm]
#enddef

#define WEAPON_SPECIAL_CHARGE
    # Canned definition of the Charge ability to be included in a
    # [specials] clause.
    [damage]
        id=charge
        name= _ "charge"
        description= _ "When used offensively, this attack deals double damage to the target. It also causes this unit to take double damage from the target’s counterattack."
        special_note={INTERNAL:SPECIAL_NOTES_CHARGE}
        multiply=2
        apply_to=both
        active_on=offense
    [/damage]
#enddef

#define WEAPON_SPECIAL_GUARD
    # Canned definition of the Guard ability to be included in a
    # [specials] clause.
    [damage]
        id=guard
        name= _ "guard"
        description= _ "This attack blocks half of the damage from its target’s strikes."
        special_note= _ "This unit’s guarding attack can halve incoming damage, but only when used in combat."
        multiply=0.5
        apply_to=opponent
    [/damage]
#enddef

#define WEAPON_SPECIAL_DRAIN
    # Canned definition of the Drain ability to be included in a
    # [specials] clause.
    [drains]
        id=drains
        name= _ "drains"
        description= _ "This unit drains health from living units, healing itself for half the amount of damage it deals (rounded down)."
        special_note={INTERNAL:SPECIAL_NOTES_DRAIN}
    [/drains]
#enddef

#define WEAPON_SPECIAL_FIRSTSTRIKE
    # Canned definition of the First-strike ability to be included in a
    # [specials] clause.
    [firststrike]
        id=firststrike
        name= _ "first strike"
        description= _ "This unit always strikes first with this attack, even if they are defending."
        special_note={INTERNAL:SPECIAL_NOTES_FIRSTSTRIKE}
    [/firststrike]
#enddef

#define WEAPON_SPECIAL_POISON
    # Canned definition of the Poison ability to be included in a
    # [specials] clause.
    [poison]
        id=poison
        name= _ "poison"
        description= _ "This attack poisons living targets. Poisoned units lose 8 HP every turn until they are cured or are reduced to 1 HP. Poison cannot, of itself, kill a unit."
        special_note={INTERNAL:SPECIAL_NOTES_POISON}
    [/poison]
#enddef

#define WEAPON_SPECIAL_STUN
    # Canned definition of the Stun ability to be included in a
    # [specials] clause.
    [stun]
        id=stun
        name= _ "stun"
        description= _ "This attack hits so hard that the opponent is dazed and can no longer enforce a zone of control. The effect wears off on the opponent’s next turn."
        special_note=_ "This unit is able to stun its enemies, disrupting their zones of control."
    [/stun]
#enddef

#define WEAPON_SPECIAL_ARCANE
    # Canned definition of the Arcane ability to be included in a
    # [specials] clause.
    [damage_type]
        id=arcane_damage
        name= _ "arcane"
        description= _ "This attack combines the arcane type with the type of weapon used so that resistance to the arcane type does not penalize the user."
        special_note=_ "This unit can use the arcane type when the opponent is particularly sensitive to it in relation to the weapon on which it is applied."
        alternative_type=arcane
    [/damage_type]
#enddef

#define WEAPON_SPECIAL_INTERCEPT
    [extra_attack]#I think it's a good idea to call abilities which launch extra attacks (even if without combat XP) [extra_attack]
        id=intercept
        name= _ "intercept"
        female_name= _ "intercept"
        description=_ "When an enemy unit enters an adjacent space, the wielder immediately executes an uncountered intercepting strike with this weapon."
        special_note=_ "Delivers a full-power, uncountered attack when enemies move adjacent. Activates once per turn."
        [filter_self] #so this shows as inactive in combat preview, since the ability doesn't affect regular combat at all
            [not]
            [/not]
        [/filter_self]
        uses_per_turn = 1 #sets how often per turn the weapon special can be triggered
        #strike_limit = 1 #sets maximum amount of strikes, still bounded by weapons strike number
        {WEAPON_SPECIAL_INTERCEPT_EVENT}
    [/extra_attack]
#enddef

#define WEAPON_SPECIAL_INTERCEPT_EVENT
    [event]
        name=side turn
        first_time_only=no
        id=weapon_special_intercept_recharge_1
        [lua]
            code=<<
local units = wesnoth.units.find_on_map({side=wml.variables["side_number"],{"and",{{"has_attack",{special_id = "intercept"}}}}})
for _,u in ipairs(units) do
    u.variables.intercept_used = 0
end
>>
        [/lua]
    [/event]
    [event]
        name=recruit,recall
        id=weapon_special_intercept_recharge_2
        first_time_only=no
        [filter]
            formula="self.wml_vars.intercept_used = true"
        [/filter]
        [lua]
            code=<<
local u = wesnoth.units.get(wesnoth.current.event_context.x1, wesnoth.current.event_context.y1)
u.variables.intercept_used = 0
>>
        [/lua]
    [/event]
    [event]
        name = enter_hex
        id = intercept_weapon_special_event
        first_time_only = no
        [filter]
            [filter_adjacent]
                [has_attack]
                    special_id = intercept
                [/has_attack]
                is_enemy = yes
            [/filter_adjacent]
        [/filter]
        [lua]
            code=<<
--attacker is e
--defender is u

local textdomain = wesnoth.textdomain "wesnoth-help" -- this isn't the bast name, but undercore "_" is in Lua widely used for unused variables

local c = wesnoth.current.event_context
local x1 = c.x1
local y1 = c.y1
if x1 ~= c.unit_x or y1 ~= c.unit_y then
    return
end
local u = wesnoth.units.get(x1,y1)

local enemies = wesnoth.units.find_on_map({{"filter_adjacent",{id=u.id, is_enemy = true}},{"has_attack",{special_id = "intercept"}}})
local iter = #enemies

while iter ~= 0 do
    local e = enemies[iter]
    local i = 1
    local special
    while e.attacks[i] ~= nil do
        special = wml.find_child(e.attacks[i].specials,{id="intercept"})
        if special ~= nil then
            break
        end
        i = i + 1
    end
    if not e.variables.intercept_used then
        e.variables.intercept_used = 0
    end
    if special.uses_per_turn and special.uses_per_turn <= e.variables.intercept_used then
        table.remove(enemies,iter)
    end
    iter = iter - 1
end

if #enemies == 0 then return end

local animator =      wesnoth.units.create_animator()
local sheath_weapon = wesnoth.units.create_animator()

for iter,e in ipairs(enemies) do
    local i = 1
    while e.attacks[i] ~= nil do
        local weapon = wml.find_child(e.attacks[i].specials,{id="intercept"})
        if weapon ~= nil then
            break
        end
        i = i + 1
    end
    local attacking_weapon=i
    local loc = e.loc
    local loc2 = u.loc
    local _, _, e_stats, u_stats = wesnoth.simulate_combat(e,attacking_weapon, u)
    local w = e.attacks[attacking_weapon]
    local w2 = nil
    local w2_cfg=nil
    if u_stats.name ~= nil then
        w2 = u.attacks[u_stats.name]
        w2_cfg = w2.__cfg
    end
    e.facing=wesnoth.map.get_relative_dir(e.x, e.y, u.x, u.y) --doesnt work if unit has no animation for the draw...
    animator:add(e, "draw_weapon", "hit",{with_bars = true, primary = w, secondary = w2})
    sheath_weapon:add(e, "sheath_weapon", "hit",{with_bars = true, primary = w, secondary = w2})
    if iter == 1 then --when drawing weapons u is already looking towards first e
        u.facing=wesnoth.map.get_relative_dir(u.x, u.y,e.x, e.y)
        animator:add(u, "draw_weapon", "hit",{with_bars = true, primary = w, secondary = w2})
        sheath_weapon:add(u, "sheath_weapon", "hit",{with_bars = true, primary = w, secondary = w2})
    end
end
animator:run()
animator:clear()
for iter,e in ipairs(enemies) do
    e.variables.intercept_used = e.variables.intercept_used and e.variables.intercept_used + 1 or 1
    local i = 1
    while e.attacks[i] ~= nil do
        local weapon = wml.find_child(e.attacks[i].specials,{id="intercept"})
        if weapon ~= nil then
            break
        end
        i = i + 1
    end
    local attacking_weapon=i
    local last_strike = false
    local strike_number = 0
    while not last_strike do
        strike_number = strike_number + 1
        e.facing=wesnoth.map.get_relative_dir(e.x, e.y, u.x, u.y)
        u.facing=wesnoth.map.get_relative_dir(u.x, u.y,e.x, e.y)
        -- u.attacks[e.variables.us_weapon] = {movement_used=100000,attacks_used=1}
        local loc = e.loc
        local loc2 = u.loc
        local _, _, e_stats, u_stats = wesnoth.simulate_combat(e,attacking_weapon, u)-- Defensive specials of enemy weapon do apply, but enemy doesn't fight back - makes sence for things like shield block
        local w = e.attacks[attacking_weapon]

        local strike_limit = wml.find_child(w.specials,{id="intercept"}).strike_limit
        if not strike_limit or strike_limit > e_stats.num_blows then
            strike_limit = e_stats.num_blows
        end
        last_strike = strike_number >= strike_limit
        local w2 = nil
        local w2_cfg=nil
        if u_stats.name ~= nil then
            w2 = u.attacks[u_stats.name]
            w2_cfg = w2.__cfg
        end
        if mathx.random() < (e_stats.chance_to_hit/100) then

            local damage_inflicted = math.floor(e_stats.damage)

            local drain = 0
            if e_stats.drains then
                drain = math.floor(math.min((math.min(damage_inflicted,u.hitpoints) * e_stats.drain_percent / 100) + e_stats.drain_constant, math.max(e.max_hitpoints - e.hitpoints,0)))
            end
            local text = ""
            if drain ~= 0 then
                text = text..drain
            end

            local text2 =  damage_inflicted.."\n"
            local add_tab = false
            local gender = u.gender
            local statuses = {}

            local function set_status(ability, name, male_string, female_string, sound)
                if not e_stats[ability] or u.status[name] then return end
                if gender == "female" then
                    text2 = string.format("%s%s%s", text2, tostring(female_string), "\n")
                else
                    text2 = string.format("%s%s%s", text2, tostring(male_string), "\n")
                end

                statuses[#statuses+1]=name
                add_tab = true

                if sound then -- for unhealable, that has no sound
                    wesnoth.audio.play(sound)
                end
            end
            --TODO: check if specials are active once a convenient API is provided
            if not u.status.unpoisonable then
                set_status("poisons","poisoned", textdomain"poisoned", textdomain"female^poisoned", "poison.ogg")
            end
            set_status("slows","slowed", textdomain"slowed", textdomain"female^slowed", "slowed.wav")
            set_status("petrifies","petrified", textdomain"petrified", textdomain"female^petrified", "petrified.ogg")
            if add_tab then
                text2 = string.format("%s%s", "     ", text2)
            end

            animator:add(e, "attack", "hit",{with_bars = true, primary = w, secondary = w2, text = text,color={0,255,0}})
            animator:add(u, "defend", "hit",{with_bars = true, primary = w, secondary = w2, text = text2,color={255,0,0}})
            animator:run()
            animator:clear()
            for i=1, #statuses do
                u.status[statuses[i]] = true
            end
            e.hitpoints=(e.hitpoints + drain)
            u.hitpoints=(u.hitpoints - e_stats.damage)
            wesnoth.game_events.fire("attacker_hits", e.loc, u.loc, {{"first",w.__cfg},{"second",w2_cfg},damage_inflicted=damage_inflicted})
                if u.valid == nil or u.hitpoints <= 0 then
                sheath_weapon:run()
                wesnoth.game_events.fire("attack end", u.loc, loc2, {{"first",wml.get_child(wesnoth.current.event_context,"weapon")},{"second",wml.get_child(wesnoth.current.event_context,"second_weapon")}})
                if u.valid == nil then
                    --u doesn't exist PROPPER DEATH EVENTS should be fired already, by some other code (modders thing)
                    goto enemy_killed
                end
                wesnoth.game_events.fire("last breath", loc2, e.loc, {{"first",w2_cfg},{"second",w.__cfg}}) --inverted
                animator:add(u, "death", "hit",{with_bars = false, primary = w2, secondary = w}) --inverted
                animator:run()
                animator:clear()
                u_level = u.level
                u_id= u.id
                wesnoth.game_events.fire("die", u.loc, e.loc, {{"first",w2_cfg},{"second",w.__cfg}}) --inverted
                wesnoth.wml_actions.kill({ id = u_id, animate = false, fire_event = false})
                if u_level == 0 then
                    e.experience = wesnoth.game_config.kill_experience * 0.5
                    e:advance(true,true)
                else
                    e.experience = e.experience +(u_level * wesnoth.game_config.kill_experience)
                    e:advance(true,true)
                end
                -- TODO doesn't work for berserker (not intended, just a warning for future me), untested with plague
                goto enemy_killed
            end
        else
            animator:add(e, "attack", "miss",{with_bars = true, primary = w, secondary = w2})
            animator:add(u, "defend", "miss",{with_bars = true, primary = w2, secondary = w})--inverted
            animator:run()
            animator:clear()
            wesnoth.game_events.fire("attacker_misses", e.loc, u.loc, {{"first",w.__cfg},{"second",w2_cfg}})
        end
    end
end
::enemy_killed::
sheath_weapon:run()
>>
        [/lua]
    [/event]

    # following code is solely to highlight hexes that can be attacked by the weapon special
    # this event is necessary to add the logic normally added by preload event when those events are first added into the game
    # preload must be used to make lua code save/load safe, but will not trigger if it only gets added when unit with this ability first appears in the game
    # once this gets propperly handled in mainline, we can simplify this part
    [event]
        name = unit_placed
        id = init_intercept_halo_select
        first_time_only = yes
        [fire_event]
            id = init_intercept_halo
        [/fire_event]
    [/event]
    [event]
        name = preload
        id = init_intercept_halo
        first_time_only = no
        [lua]
            code=<<
if rawget(_G, "intercept_graphic_loaded") ~= nil then -- because of the double loading event isn't ideal, we have to keep this check
    goto execute_nothing -- so as not to wrap the whole thing in one giant if
end

intercept_graphic_loaded = true
halo_id = "misc/new-battle.png"
intercept_halo_locations = {}

function has_intercept_ability(u) --helper function for filtering
    --if u.hitpoints <= 0 then
    --    return false
    --end
    for _, attack in ipairs(u.attacks) do
         local special = wml.find_child(attack.specials,{id="intercept"})
          if special and (not special.uses_per_turn or not u.variables.intercept_used or special.uses_per_turn > u.variables.intercept_used) then
            return true
          end
    end
    --TODO: check if ability is active once a convenient API is provided
    return false
end

function clear_intercept_halo_locations() -- shared cleanup logic
    if next(intercept_halo_locations) ~= nil then --check if intercept_halo_locations is empty so that redraw is not unnecessarily called
        for _, loc in ipairs(intercept_halo_locations) do
            wesnoth.interface.remove_hex_overlay(loc[1], loc[2], halo_id)
            wml.fire("redraw")
        end
        intercept_halo_locations = {}
        return true
    end
    return false
end

local old_on_mouse_move = wesnoth.game_events.on_mouse_move
wesnoth.game_events.on_mouse_move = function(x,y)
    local sx, sy = wesnoth.interface.get_selected_hex()
    x = sx or x
    y = sy or y
    local u = wesnoth.units.get(x, y)
    clear_intercept_halo_locations()
    if u then
        for _, candidate_hex in ipairs(wesnoth.paths.find_reach(u)) do
            if not wesnoth.units.get(candidate_hex) then -- not placing under units, those tiles cannot be moved onto and the overlay looks weird placed under units
                local n, ne, se, s, sw, nw = wesnoth.map.get_adjacent_hexes(candidate_hex)
                for _, loc in ipairs({n, ne, se, s, sw, nw}) do
                    local e = wesnoth.units.get(loc[1], loc[2])
                    if e and wesnoth.sides.is_enemy(e.side, u.side) and has_intercept_ability(e) then
                        wesnoth.interface.add_hex_overlay(candidate_hex[1], candidate_hex[2], { image = halo_id })
                        table.insert(intercept_halo_locations, {candidate_hex[1], candidate_hex[2]})
                    end
                end
            end
        end
    end
    wml.fire("redraw")
    return old_on_mouse_move(x,y)
end

-- if possible, should be replaced when some sort of deselect trigger is available - not problem rn for any case I could think of, but in theory deselect could happen without left-clicking
local old_on_mouse_button = wesnoth.game_events.on_mouse_button
wesnoth.game_events.on_mouse_button = function(x,y,button,event)
    if event == "up" and not wesnoth.interface.get_selected_hex() then -- meaning a leftclick, but no unit was selected -> no unit is neither selectet nor hovered-over
        clear_intercept_halo_locations(x, y)
        wml.fire("redraw")
    end
    return old_on_mouse_button(x,y,button,event)
end

::execute_nothing::
>>
        [/lua]
    [/event]
#enddef
