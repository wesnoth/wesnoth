#textdomain wesnoth
# Interface shortcut macros.

# These don't depend on any other macros.  Please don't change this.
# ! in comments is used to generate HTML documentation; ignore it otherwise.

#define MESSAGE SPEAKER IMAGE CAPTION TEXT
    # Displays a text message spoken by SPEAKER.
    # Speaker can be any of: narrator, unit and second_unit
    # For example, let's have the narrator, which looks like a faery
    # express some feelings on the undead:
    #! {MESSAGE narrator "units/elves-wood/shyde.png" _ "Faery" _ "Aarr! Them be undeadies! Loooks at them.."}
    [message]
        speaker={SPEAKER}
        message={TEXT}
        image={IMAGE}
        caption={CAPTION}
    [/message]
#enddef

#define FLOATING_TEXT FILTER COLOUR TEXT
    # Floats the given text above the given unit in the same manner as damage
    # numbers are displayed in combat.
    # For example when a unit steps on a hidden trap and is dealt 8 damage, let's
    # show this to the player like all other damage is:
    #! {FLOATING_TEXT x,y=$x1,$y1 255,0,0 "8"}
    [store_unit]
        [filter]
            {FILTER}
        [/filter]

        kill=no
        variable=FLOATING_TEXT_temp
    [/store_unit]

    [unstore_unit]
        variable=FLOATING_TEXT_temp
        find_vacant=no
        red,green,blue={COLOUR}
        text={TEXT}
    [/unstore_unit]

    {CLEAR_VARIABLE FLOATING_TEXT_temp}
#enddef

#define HIGHLIGHT_UNIT FILTER
    # Blinks the specified unit(s) a few times. Can be used to pinpoint an
    # important unit to the player.
    [store_unit]
        [filter]
            {FILTER}
        [/filter]

        kill=no
        variable=HIGHLIGHT_UNIT_temp
    [/store_unit]

    [scroll_to]
        x,y=$HIGHLIGHT_UNIT_temp[$i].x,$HIGHLIGHT_UNIT_temp[$i].y
    [/scroll_to]

    {FOREACH HIGHLIGHT_UNIT_temp i}
        [kill]
            x,y=$HIGHLIGHT_UNIT_temp[$i].x,$HIGHLIGHT_UNIT_temp[$i].y
            fire_event=no
            animate=no
        [/kill]
    {NEXT i}
    [redraw][/redraw]
    [delay]
        time=300
    [/delay]
    {FOREACH HIGHLIGHT_UNIT_temp i}
        [unstore_unit]
            variable=HIGHLIGHT_UNIT_temp[$i]
            find_vacant=no
        [/unstore_unit]
    {NEXT i}
    [redraw][/redraw]
    [delay]
        time=300
    [/delay]

    {FOREACH HIGHLIGHT_UNIT_temp i}
        [kill]
            x,y=$HIGHLIGHT_UNIT_temp[$i].x,$HIGHLIGHT_UNIT_temp[$i].y
            fire_event=no
            animate=no
        [/kill]
    {NEXT i}
    [redraw][/redraw]
    [delay]
        time=300
    [/delay]
    {FOREACH HIGHLIGHT_UNIT_temp i}
        [unstore_unit]
            variable=HIGHLIGHT_UNIT_temp[$i]
            find_vacant=no
        [/unstore_unit]
    {NEXT i}
    [redraw][/redraw]
    [delay]
        time=300
    [/delay]

    {FOREACH HIGHLIGHT_UNIT_temp i}
        [kill]
            x,y=$HIGHLIGHT_UNIT_temp[$i].x,$HIGHLIGHT_UNIT_temp[$i].y
            fire_event=no
            animate=no
        [/kill]
    {NEXT i}
    [redraw][/redraw]
    [delay]
        time=300
    [/delay]
    {FOREACH HIGHLIGHT_UNIT_temp i}
        [unstore_unit]
            variable=HIGHLIGHT_UNIT_temp[$i]
            find_vacant=no
        [/unstore_unit]
    {NEXT i}
    [redraw][/redraw]
    [delay]
        time=300
    [/delay]

    {CLEAR_VARIABLE HIGHLIGHT_UNIT_temp}
#enddef

#define HIGHLIGHT_IMAGE X Y IMAGE BACKGROUND
    # Scrolls to the given location, blinks the given image in and out a few
    # times, and then leaves the image in place. Use this to pinpoint an
    # important location to the player. If there's an existing [item] on the
    # location, specify it as the BACKGROUND or else it'll get lost during the
    # blinking.
    [scroll_to]
        x,y={X},{Y}
        check_fogged=false
    [/scroll_to]
    [item]
        x,y={X},{Y}
        halo={IMAGE}
    [/item]
    [redraw][/redraw]
    [delay]
        time=300
    [/delay]
    [removeitem]
        x,y={X},{Y}
    [/removeitem]
    [item]
        x,y={X},{Y}
        image={BACKGROUND}
    [/item]
    [redraw][/redraw]
    [delay]
        time=300
    [/delay]
    [item]
        x,y={X},{Y}
        halo={IMAGE}
    [/item]
    [redraw][/redraw]
    [delay]
        time=300
    [/delay]
    [removeitem]
        x,y={X},{Y}
    [/removeitem]
    [item]
        x,y={X},{Y}
        image={BACKGROUND}
    [/item]
    [redraw][/redraw]
    [delay]
        time=300
    [/delay]
    [item]
        x,y={X},{Y}
        halo={IMAGE}
    [/item]
    [redraw][/redraw]
    [delay]
        time=300
    [/delay]
    [removeitem]
        x,y={X},{Y}
    [/removeitem]
    [item]
        x,y={X},{Y}
        image={BACKGROUND}
    [/item]
    [redraw][/redraw]
    [delay]
        time=300
    [/delay]
    [item]
        x,y={X},{Y}
        image={IMAGE}
    [/item]
    [redraw][/redraw]
#enddef

#define CLEAR_FOG SIDE X Y RADIUS
    # Clears fog in a specific area for the given side. This is to be used only
    # for the duration of an event: always use {UNCLEAR_FOG} (below) before the
    # event exits, or otherwise you'll be left with fake fog clearer units on
    # the map.
    [if]
        [have_unit]
            type=Fog Clearer
        [/have_unit]

        [then]
            [set_variable]
                name=fog_clearer_i
                add=1
            [/set_variable]
        [/then]

        [else]
            [set_variable]
                name=fog_clearer_i
                value=1
            [/set_variable]
        [/else]
    [/if]

    [unit]
        side={SIDE}
        type=Fog Clearer
        description=fog_clearer_$fog_clearer_i
        x,y={X},{Y}
        max_moves={RADIUS}
    [/unit]

    [store_unit]
        [filter]
            description=fog_clearer_$fog_clearer_i
        [/filter]

        kill=no
        variable=new_fog_clearer
    [/store_unit]

    [hide_unit]
        x,y=$new_fog_clearer.x,$new_fog_clearer.y
    [/hide_unit]

    [redraw]
        side={SIDE}
    [/redraw]
#enddef

#define UNCLEAR_FOG
    # Restores fog that was temporarily cleared (check CLEAR_FOG above). Only
    # one UNCLEAR_FOG is required no matter how many times CLEAR_FOG was used.
    [kill]
        type=Fog Clearer
        animate=no
        fire_event=no
    [/kill]

    [clear_variable]
        name=fog_clearer_i
    [/clear_variable]
#enddef

#define SET_LABEL X Y TEXT
    # Puts TEXT on the map at X,Y.  Strictly a syntactic shortcut.
    #
    # For example:
    #! {SET_LABEL 4 7 _ "There be dragons here!"}
    [label]
        x={X}
        y={Y}
        text={TEXT}
    [/label]
#enddef

#define REMOVE_LABEL X Y
    # Removes a label from a given tile.
    #
    # For example, remove it from 4,7
    #! {REMOVE_LABEL 4 7}
    [label]
        x={X}
        y={Y}
        text=""
    [/label]
#enddef

#define SET_LABEL_PERSISTANT X Y TEXT
    # Sets a label on tile x,y that gets reset every sideturn in case
    # someone clears it.
    #
    # Example:
    #! {SET_LABEL_PERSISTANT 4 7 _ "There really will be dragons here!!"}
    {SET_LABEL {X} {Y} ({TEXT}) }
    {ON_SIDETURN (
    {SET_LABEL {X} {Y} ({TEXT}) }
    )}
#enddef

#define SET_IMAGE X Y IMAGE
    # Places an image at a given tile, shrinking it to fit the tile
    #
    # For example, let's put a tent on tile 14,5
    #! {SET_IMAGE 14 5 "terrain/tent.png"}
    [item]
        x,y={X},{Y}
        image={IMAGE}
    [/item]
#enddef

#define REMOVE_IMAGE X Y
    # Removes a previously set image from a tile.
    #
    # Example:
    #! {REMOVE_IMAGE 14 5}
    [removeitem]
        x,y={X},{Y}
    [/removeitem]
#enddef

#define SET_IMAGE_AND_LABEL_PERSISTANT X Y IMAGE TEXT
    # Shorthand for setting both a persistant label and image at once.
    {SET_LABEL_PERSISTANT {X} {Y} ({TEXT}) }
    {SET_IMAGE {X} {Y} ({IMAGE}) }
#enddef

#define SCROLL X Y
    # Scrolls the screen by the specified offsets
    #
    # For example, let's scroll 5 right and 3 down:
    #! {SCROLL 5 3}
    [scroll]
        x={X}
        y={Y}
    [/scroll]
#enddef

#define SCROLL_TO X Y
    # Scrolls the screen to focus on the specified coordinates
    #
    # For example, let's focus on 26,35:
    #! {SCROLL 26 35}
    [scroll_to]
        x={X}
        y={Y}
    [/scroll_to]
#enddef

#define TREMOR
    # Visuals and sound for an earth tremor.
    [sound]
        name="rumble.ogg"
    [/sound]
    [scroll]
        x=5
        y=0
    [/scroll]
    [scroll]
        x=-10
        y=0
    [/scroll]
    [scroll]
        x=5
        y=5
    [/scroll]
    [scroll]
        x=0
        y=-10
    [/scroll]
    [scroll]
        x=0
        y=5
    [/scroll]
#enddef

#define EARTHQUAKE ACTION
    # Creates an earthquake-effect while performing ACTION
    # For example we could kill all non-leader units in the earthquake:
    #! {EARTHQUAKE (
    #!   [kill]
    #!       canrecruit=0
    #!       animate=yes
    #!   [/kill]
    #! )}
    [sound]
        name=lightning.ogg
    [/sound]
    {SCROLL 2 1}
    {SCROLL -1 -3}
    {SCROLL -3 1}
    {ACTION}
    {SCROLL 1 3}
    {SCROLL 1 -2}
#enddef

#define COLOR_ADJUST RED GREEN BLUE
    # Adjusts the color of the screen by a tint or red, green and blue
    # for example, let's make it very blueish:
    #! {COLOR_ADJUST 0 0 100}
    [colour_adjust]
        red={RED}
        green={GREEN}
        blue={BLUE}
    [/colour_adjust]
#enddef

# Flashes the screen with a given color performing ACTION
# These macros come in WHITE, RED, GREEN and BLUE and can
# easily be expanded for ORANGE, PURPLE etc.
#
# Example: flash the screen to scare the player:
#! {FLASH_GREEN ()}
#! {FLASH_RED ()}
#! {FLASH_BLUE ()}
#! {FLASH_WHITE ()}

#define FLASH_WHITE ACTION
    # Flash the screen momentarily white.
    {COLOR_ADJUST 67 67 67}
    {COLOR_ADJUST 100 100 100}
    {ACTION}
    {COLOR_ADJUST 33 33 33}
    {COLOR_ADJUST 0 0 0}
#enddef

#define FLASH_RED ACTION
    # Flash the screen momentarily red.
    {COLOR_ADJUST 67 0 0}
    {COLOR_ADJUST 100 0 0}
    {ACTION}
    {COLOR_ADJUST 33 0 0}
    {COLOR_ADJUST 0 0 0}
#enddef

#define FLASH_GREEN ACTION
    # Flash the screen momentarily green.
    {COLOR_ADJUST 0 67 0}
    {COLOR_ADJUST 0 100 0}
    {ACTION}
    {COLOR_ADJUST 0 33 0}
    {COLOR_ADJUST 0 0 0}
#enddef

#define FLASH_BLUE ACTION
    # Flash the screen momentarily blue.
    {COLOR_ADJUST 0 0 67}
    {COLOR_ADJUST 0 0 100}
    {ACTION}
    {COLOR_ADJUST 0 0 33}
    {COLOR_ADJUST 0 0 0}
#enddef

#define THUNDER ACTION
    # Creates a thunder-and-lightning effect while performing ACTION.
    # For example, player 3 might disappear in the flash of lightning:
    #! {THUNDER (
    #!   [store_unit]
    #!       [filter]
    #!           side=3
    #!       [/filter]
    #!       variable=player3
    #!       kill=yes
    #!   [/store_unit]
    #! )}
    [sound]
        name=lightning.ogg
    [/sound]
    {FLASH_WHITE ({ACTION}) }
#enddef
